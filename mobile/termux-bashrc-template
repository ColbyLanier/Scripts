# ~/.bashrc for Termux (phone)
# Minimal quality-of-life setup + token-api integration

# ====================================================
# ENVIRONMENT CONFIGURATION
# ====================================================
# Mac Mini IP for Token-API HTTP endpoints
MINI_IP="100.95.109.23"

# Source local .env file for optional overrides
if [[ -f "$HOME/.env" ]]; then
    set -a
    source "$HOME/.env"
    set +a
fi

# ====================================================
# STANDARDIZED SSH (via SSH config + redirect-on-exit)
# ====================================================
# SSH config (~/.ssh/config) defines: desktop, wsl, mac, mini, phone
# All use key-based authentication with id_ed25519
#
# When SSH'd into a host and you run ssh-wsl (for example), instead of
# nesting (phone→mac→wsl), this redirects: closes the mac session and
# connects directly from phone to wsl. Use --proxy to nest intentionally.

_ssh_target_to_host() {
    case "$1" in
        mac)   echo "mini" ;;
        wsl)   echo "wsl" ;;
        phone) echo "phone" ;;
        *)     echo "" ;;
    esac
}

_ssh_ip_to_host() {
    case "$1" in
        100.95.109.23)  echo "mini" ;;
        100.69.198.87)  echo "desktop" ;;
        100.66.10.74)   echo "wsl" ;;
        100.102.92.24)  echo "phone" ;;
        *)              echo "" ;;
    esac
}

ssh-connect() {
    local TARGET="$1"; shift
    local PROXY=false
    [[ "$1" == "--proxy" ]] && { PROXY=true; shift; }

    local HOST=$(_ssh_target_to_host "$TARGET")
    if [[ -z "$HOST" ]]; then
        echo "Unknown target: $TARGET (expected mac, wsl, or phone)"
        return 1
    fi

    # Redirect-on-exit: if in SSH session and not --proxy
    if [[ -n "$SSH_CONNECTION" ]] && ! $PROXY; then
        local origin_ip="${SSH_CLIENT%% *}"
        local origin_host=$(_ssh_ip_to_host "$origin_ip")
        if [[ -n "$origin_host" ]]; then
            echo "Redirecting: closing this session → connecting to $TARGET from origin..."
            if ssh -o ConnectTimeout=3 -o BatchMode=yes "$origin_host" \
                "echo $TARGET > \$HOME/.ssh-next" 2>/dev/null; then
                # Kill parent shell to close SSH session automatically
                kill -HUP $PPID 2>/dev/null
                exit 0
            fi
            echo "Reverse SSH to origin failed, falling back to direct connection..."
        fi
        exec ssh "$HOST" "$@"
    fi

    # Direct connection with redirect loop
    while true; do
        if [[ $# -gt 0 ]]; then
            ssh "$HOST" -t "$*"
            break
        else
            ssh "$HOST"
        fi
        if [[ -f ~/.ssh-next ]]; then
            local next=$(cat ~/.ssh-next)
            rm -f ~/.ssh-next
            HOST=$(_ssh_target_to_host "$next")
            TARGET="$next"
            if [[ -z "$HOST" ]]; then
                echo "Invalid redirect target: $next"
                break
            fi
            echo "Redirecting to $TARGET..."
        else
            break
        fi
    done
}

ssh-mac() { ssh-connect mac "$@"; }
ssh-wsl() { ssh-connect wsl "$@"; }

# Backwards-compatible aliases
alias sshpc="ssh-wsl"
alias sshmac="ssh-mac"
alias sshmini="ssh-mac"

# Clear old aliases to prevent syntax errors when transitioning alias→function
unalias fetch-bashrc fetch-properties 2>/dev/null

# Fetch and update .bashrc from Mac (syncs WSL→Mac first, then copies)
fetch-bashrc() {
    echo "Syncing Scripts repo (WSL → Mac)..."
    ssh mac "~/Scripts/cli-tools/bin/scripts-sync pull" 2>/dev/null
    echo "Fetching bashrc from Mac..."
    scp mac:~/Scripts/mobile/termux-bashrc-template ~/.bashrc && source ~/.bashrc && echo "bashrc updated and reloaded"
}

# Fetch and update termux.properties from Mac (syncs WSL→Mac first, then copies)
fetch-properties() {
    echo "Syncing Scripts repo (WSL → Mac)..."
    ssh mac "~/Scripts/cli-tools/bin/scripts-sync pull" 2>/dev/null
    echo "Fetching termux.properties from Mac..."
    scp mac:~/Scripts/mobile/termux-properties-template ~/.termux/termux.properties && termux-reload-settings && echo "termux properties updated and reloaded"
}

# ====================================================
# HISTORY
# ====================================================
HISTCONTROL=ignoreboth
shopt -s histappend
HISTSIZE=1000
HISTFILESIZE=2000

# ====================================================
# SHELL OPTIONS
# ====================================================
shopt -s checkwinsize

# ====================================================
# PROMPT
# ====================================================
PS1='\[\033[01;32m\]\u@phone\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '

# ====================================================
# SMART CD SYSTEM - Shorthand path expansion with enhancements
# ====================================================
# Usage: cd <shortcut>[/subpath]  e.g., cd proj/src, cd dl/photos
# ====================================================

# Directory shorthand mappings - CUSTOMIZE THESE FOR YOUR PHONE
# Example shortcuts (modify paths to match your Termux setup):
declare -A CD_SHORTCUTS=(
    [dl]="$HOME/storage/downloads"
    [dcim]="$HOME/storage/dcim"
    [docs]="$HOME/storage/documents"
    [proj]="$HOME/projects"
    # Add your own shortcuts here
)

# Smart cd function - expands shortcuts and tracks history
cd() {
    local target="$1"

    # No argument = go home
    [[ -z "$target" ]] && { builtin cd; return; }

    # Special cases: pass through directly
    # - dash (previous dir), ~ paths, .. patterns, absolute paths
    [[ "$target" == "-" || "$target" == "~"* || "$target" == /* || "$target" =~ ^\.\.?(/|$) ]] && {
        builtin cd "$target"
        return
    }

    # Extract first path component to check for shortcut
    local first_part="${target%%/*}"

    # Check if it's a known shortcut (use -v to test if key exists)
    if [[ -n "$first_part" && -v "CD_SHORTCUTS[$first_part]" ]]; then
        if [[ "$target" == "$first_part" ]]; then
            # Just the shortcut, no subpath
            builtin cd "${CD_SHORTCUTS[$first_part]}"
        else
            # Shortcut with subpath: proj/src -> full/path/src
            local rest="${target#*/}"
            builtin cd "${CD_SHORTCUTS[$first_part]}/$rest"
        fi
    else
        # Not a shortcut - regular cd behavior
        builtin cd "$target"
    fi
}

# List available shortcuts
cdhelp() {
    echo "CD Shortcuts (customize in ~/.bashrc):"
    for key in "${!CD_SHORTCUTS[@]}"; do
        echo "  $key → ${CD_SHORTCUTS[$key]}"
    done
    echo ""
    echo "Usage: cd <shortcut>[/subpath]"
    echo "Examples: cd proj/src, cd dl/photos"
}

# Basic navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ~="cd ~"
alias b="cd -"

# Enable autocd - type directory name without 'cd'
shopt -s autocd 2>/dev/null

# cd + ls - change directory and list contents
cdl() { cd "$@" && ls -l; }

# cdg - fuzzy/grep-based directory change
cdg() {
    local pattern="$1"
    local search_dir="${2:-.}"

    # Expand shortcut if provided as second arg
    if [[ -n "$2" && -n "${CD_SHORTCUTS[$2]}" ]]; then
        search_dir="${CD_SHORTCUTS[$2]}"
    fi

    local matches
    matches=$(find "$search_dir" -maxdepth 1 -type d -iname "*${pattern}*" 2>/dev/null | grep -v "^${search_dir}$")
    local count=$(echo "$matches" | grep -c .)

    if [[ $count -eq 0 ]]; then
        echo "No directories matching '$pattern'"
        return 1
    elif [[ $count -eq 1 ]]; then
        cd "$matches"
    else
        echo "Multiple matches:"
        echo "$matches" | sed 's/.*\//  /'
    fi
}

# up N - go up N directories (e.g., up 3 = cd ../../..)
up() {
    local count="${1:-1}"
    local path=""
    for ((i=0; i<count; i++)); do
        path="../$path"
    done
    cd "$path"
}

# Directory stack helpers (pushd/popd made easy)
alias d='dirs -v'
pd() { pushd "${1:-.}" > /dev/null; }
bd() { popd > /dev/null 2>&1 || echo "Directory stack empty"; }

# Mark and jump system - bookmark directories
export MARKPATH="$HOME/.cd_marks"
[[ ! -d "$MARKPATH" ]] && mkdir -p "$MARKPATH"

mark() {
    local name="${1:-$(basename "$PWD")}"
    ln -sf "$PWD" "$MARKPATH/$name"
    echo "Marked: $name → $PWD"
}
jump() {
    local target="$MARKPATH/$1"
    if [[ -L "$target" ]]; then
        cd -P "$target"
    else
        echo "No mark named '$1'. Use 'marks' to see available marks."
        return 1
    fi
}
marks() {
    echo "Bookmarks:"
    for link in "$MARKPATH"/*; do
        [[ -L "$link" ]] && echo "  $(basename "$link") → $(readlink "$link")"
    done
}
unmark() {
    rm -f "$MARKPATH/$1" && echo "Removed mark: $1"
}

# ====================================================
# LS ALIASES
# ====================================================
alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lsg="ls | grep"
alias duh="du -h -d 1 | sort -h"

# ====================================================
# GREP ALIASES
# ====================================================
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# ====================================================
# EDITOR
# ====================================================
export EDITOR=micro
export VISUAL=micro
alias e='micro'

# ====================================================
# CONVENIENCE
# ====================================================
alias c="clear"
alias cc="clear &&"
alias python="python3"

# cdc - run claude on Mac (not installed on phone) with optional path/args
# Uses zsh -il (interactive login) so Mac sources ~/.zprofile (PATH) + ~/.zshrc (aliases)
cdc() {
    ssh -t mac "zsh -il -c 'cdc $*'"
}

# ====================================================
# COMMAND NOT FOUND — INTERACTIVE ROUTING MODAL
# ====================================================
# Fires only for genuinely missing commands (bash exit 127 hook).
# --local in any arg position suppresses the modal entirely.
command_not_found_handle() {
    local cmd="$1"; shift
    local args=("$@")

    # --local flag: suppress remote fallback, return 127 normally
    for arg in "${args[@]}"; do
        [[ "$arg" == "--local" ]] && { echo "Command not found: $cmd"; return 127; }
    done

    echo ""
    echo "Command not found: $cmd"
    echo "  1) Run on Mac"
    echo "  2) Run on WSL"
    echo "  3) Don't run remotely"
    printf "Route to: "
    read -r choice

    # Use zsh -i on Mac / bash -i on WSL so ~/.zshrc is sourced and
    # aliases/functions (like claude, monitor) are available
    case "$choice" in
        1) ssh -t mac "zsh -il -c '$cmd ${args[*]}'" ;;
        2) ssh -t wsl "bash -ic '$cmd ${args[*]}'" ;;
        *) return 127 ;;
    esac
}

# ====================================================
# UTILITY FUNCTIONS
# ====================================================
# Timestamps
alias now="date '+%Y-%m-%d %H:%M:%S'"
alias nowdate="date '+%Y-%m-%d'"
alias nowtime="date '+%H:%M:%S'"

# Quick file preview (head + tail)
peek() {
    local n="${2:-5}"
    echo "=== head $n ==="
    head -n "$n" "$1"
    echo "..."
    echo "=== tail $n ==="
    tail -n "$n" "$1"
}

# Process grep
psg() { ps aux | grep "$@" | grep -v grep; }

# Find in files
fif() { grep -rn "$@" .; }

# Extract archives
extract() {
    if [[ -f "$1" ]]; then
        case "$1" in
            *.tar.bz2)  tar xjf "$1"   ;;
            *.tar.gz)   tar xzf "$1"   ;;
            *.tar.xz)   tar xJf "$1"   ;;
            *.bz2)      bunzip2 "$1"   ;;
            *.gz)       gunzip "$1"    ;;
            *.tar)      tar xf "$1"    ;;
            *.tbz2)     tar xjf "$1"   ;;
            *.tgz)      tar xzf "$1"   ;;
            *.zip)      unzip "$1"     ;;
            *.Z)        uncompress "$1";;
            *.7z)       7z x "$1"      ;;
            *)          echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# ====================================================
# MAC-SIDE COMMANDS — explicit functions (bypass routing modal)
# Uses zsh -il -c so Mac's ~/.zshrc is sourced (needed for aliases/functions)
# ====================================================
monitor()       { ssh -t mac "zsh -il -c 'monitor'"; }
token-restart() { ssh -t mac "zsh -il -c 'token-restart $*'"; }
token-status()  { ssh -t mac "zsh -il -c 'token-status $*'"; }
instance-name() { ssh -t mac "zsh -il -c 'instance-name $*'"; }

# ====================================================
# GIT
# ====================================================
alias gs="git status"
alias gcam="git commit -a -m"
alias gba="git branch -a"
alias gc="git checkout"
alias gpush="git push origin"
alias gpull="git pull origin"
alias gadd="git add ."

# ====================================================
# SYSTEM CONTROL (Mac Mini Token-API)
# ====================================================
# Token-API now runs on Mac Mini (100.95.109.23:7777)
# Shutdown Mac Mini with 1min delay, Ctrl+C to cancel
shutdown-mini() {
    local API="http://${MINI_IP}:7777"

    echo "Initiating Mac Mini shutdown in 60 seconds... (Ctrl+C to cancel)"

    local response=$(curl -s -X POST "$API/api/system/shutdown" \
        -H "Content-Type: application/json" \
        -d '{"action": "shutdown", "delay_seconds": 60}')

    local success=$(echo "$response" | python3 -c "import sys,json; print(json.load(sys.stdin).get('success', False))" 2>/dev/null)

    if [[ "$success" != "True" ]]; then
        echo "Failed to initiate shutdown: $response"
        return 1
    fi

    trap 'echo ""; echo "Cancelling shutdown..."; curl -s -X POST "$API/api/system/shutdown/cancel" | python3 -c "import sys,json; print(json.load(sys.stdin).get(\"message\", \"Unknown\"))"; trap - INT; return 130' INT

    for i in {60..1}; do
        printf "\rShutdown in %2d seconds... (Ctrl+C to cancel)" "$i"
        sleep 1
    done

    trap - INT
    echo ""
    echo "Shutdown initiated."
}

# ====================================================
# AUTO-SSH TO MAC ON STARTUP
# ====================================================
# Start in SSH session to Mac by default. Use 'exit' to access local phone.
# Guard: only auto-SSH when opening Termux locally on the phone.
# Skip if incoming SSH session (SSH_CONNECTION set) or non-interactive shell.
if [[ -z "$SSH_CONNECTION" ]] && [[ $- == *i* ]] && [[ -z "$__AUTO_SSH_DONE" ]]; then
    export __AUTO_SSH_DONE=1
    ssh-connect mac
fi
