# ~/.bashrc for Termux (phone)
# Minimal quality-of-life setup + token-api integration

# ====================================================
# ENVIRONMENT CONFIGURATION
# ====================================================
# Source local .env file for secrets (not in repo)
# Expected vars: WSL_IP (for SSH), WINDOWS_IP (for system control)
if [[ -f "$HOME/.env" ]]; then
    set -a
    source "$HOME/.env"
    set +a
fi

# Verify required variables are set
if [[ -z "$WSL_IP" || -z "$WINDOWS_IP" ]]; then
    echo "Warning: WSL_IP or WINDOWS_IP not set. Create ~/.env with:"
    echo '  WSL_IP="wsl_tailscale_ip"'
    echo '  WINDOWS_IP="windows_tailscale_ip"'
fi

# ====================================================
# DESKTOP SSH (WSL)
# ====================================================
# SSH to WSL - Claude sessions are tracked by token-api hooks automatically
# Usage: sshpc [command] - runs command on desktop, or starts interactive session
ssh-desktop() {
  if [[ $# -gt 0 ]]; then
    ssh token@${WSL_IP} -t "$*"
  else
    ssh token@${WSL_IP}
  fi
}
alias sshpc="ssh-desktop"

# Fetch and update .bashrc from desktop
alias fetch-bashrc='ssh token@${WSL_IP} "cat /home/token/Scripts/mobile/termux-bashrc-template" > ~/.bashrc && source ~/.bashrc && echo "bashrc updated and reloaded"'

# Fetch and update termux.properties from desktop
alias fetch-properties='ssh token@${WSL_IP} "cat /home/token/Scripts/mobile/termux-properties-template" > ~/.termux/termux.properties && termux-reload-settings && echo "termux properties updated and reloaded"'

# ====================================================
# HISTORY
# ====================================================
HISTCONTROL=ignoreboth
shopt -s histappend
HISTSIZE=1000
HISTFILESIZE=2000

# ====================================================
# SHELL OPTIONS
# ====================================================
shopt -s checkwinsize

# ====================================================
# PROMPT
# ====================================================
PS1='\[\033[01;32m\]\u@phone\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '

# ====================================================
# SMART CD SYSTEM - Shorthand path expansion with enhancements
# ====================================================
# Usage: cd <shortcut>[/subpath]  e.g., cd proj/src, cd dl/photos
# ====================================================

# Directory shorthand mappings - CUSTOMIZE THESE FOR YOUR PHONE
# Example shortcuts (modify paths to match your Termux setup):
declare -A CD_SHORTCUTS=(
    [dl]="$HOME/storage/downloads"
    [dcim]="$HOME/storage/dcim"
    [docs]="$HOME/storage/documents"
    [proj]="$HOME/projects"
    # Add your own shortcuts here
)

# Smart cd function - expands shortcuts and tracks history
cd() {
    local target="$1"

    # No argument = go home
    [[ -z "$target" ]] && { builtin cd; return; }

    # Special cases: pass through directly
    # - dash (previous dir), ~ paths, .. patterns, absolute paths
    [[ "$target" == "-" || "$target" == "~"* || "$target" == /* || "$target" =~ ^\.\.?(/|$) ]] && {
        builtin cd "$target"
        return
    }

    # Extract first path component to check for shortcut
    local first_part="${target%%/*}"

    # Check if it's a known shortcut (use -v to test if key exists)
    if [[ -n "$first_part" && -v "CD_SHORTCUTS[$first_part]" ]]; then
        if [[ "$target" == "$first_part" ]]; then
            # Just the shortcut, no subpath
            builtin cd "${CD_SHORTCUTS[$first_part]}"
        else
            # Shortcut with subpath: proj/src -> full/path/src
            local rest="${target#*/}"
            builtin cd "${CD_SHORTCUTS[$first_part]}/$rest"
        fi
    else
        # Not a shortcut - regular cd behavior
        builtin cd "$target"
    fi
}

# List available shortcuts
cdhelp() {
    echo "CD Shortcuts (customize in ~/.bashrc):"
    for key in "${!CD_SHORTCUTS[@]}"; do
        echo "  $key → ${CD_SHORTCUTS[$key]}"
    done
    echo ""
    echo "Usage: cd <shortcut>[/subpath]"
    echo "Examples: cd proj/src, cd dl/photos"
}

# Basic navigation
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias ~="cd ~"
alias b="cd -"

# Enable autocd - type directory name without 'cd'
shopt -s autocd 2>/dev/null

# cd + ls - change directory and list contents
cdl() { cd "$@" && ls -l; }

# cdg - fuzzy/grep-based directory change
cdg() {
    local pattern="$1"
    local search_dir="${2:-.}"

    # Expand shortcut if provided as second arg
    if [[ -n "$2" && -n "${CD_SHORTCUTS[$2]}" ]]; then
        search_dir="${CD_SHORTCUTS[$2]}"
    fi

    local matches
    matches=$(find "$search_dir" -maxdepth 1 -type d -iname "*${pattern}*" 2>/dev/null | grep -v "^${search_dir}$")
    local count=$(echo "$matches" | grep -c .)

    if [[ $count -eq 0 ]]; then
        echo "No directories matching '$pattern'"
        return 1
    elif [[ $count -eq 1 ]]; then
        cd "$matches"
    else
        echo "Multiple matches:"
        echo "$matches" | sed 's/.*\//  /'
    fi
}

# up N - go up N directories (e.g., up 3 = cd ../../..)
up() {
    local count="${1:-1}"
    local path=""
    for ((i=0; i<count; i++)); do
        path="../$path"
    done
    cd "$path"
}

# Directory stack helpers (pushd/popd made easy)
alias d='dirs -v'
pd() { pushd "${1:-.}" > /dev/null; }
bd() { popd > /dev/null 2>&1 || echo "Directory stack empty"; }

# Mark and jump system - bookmark directories
export MARKPATH="$HOME/.cd_marks"
[[ ! -d "$MARKPATH" ]] && mkdir -p "$MARKPATH"

mark() {
    local name="${1:-$(basename "$PWD")}"
    ln -sf "$PWD" "$MARKPATH/$name"
    echo "Marked: $name → $PWD"
}
jump() {
    local target="$MARKPATH/$1"
    if [[ -L "$target" ]]; then
        cd -P "$target"
    else
        echo "No mark named '$1'. Use 'marks' to see available marks."
        return 1
    fi
}
marks() {
    echo "Bookmarks:"
    for link in "$MARKPATH"/*; do
        [[ -L "$link" ]] && echo "  $(basename "$link") → $(readlink "$link")"
    done
}
unmark() {
    rm -f "$MARKPATH/$1" && echo "Removed mark: $1"
}

# ====================================================
# LS ALIASES
# ====================================================
alias ls='ls --color=auto'
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lsg="ls | grep"

# ====================================================
# GREP ALIASES
# ====================================================
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'

# ====================================================
# CONVENIENCE
# ====================================================
alias c="clear"
alias cc="clear &&"
alias python="python3"

# cdc - cd to path and run claude with optional prompt
cdc() {
    if [[ -n "$1" ]]; then
        cd "$1" || return 1
    fi
    clear
    claude "${@:2}"
}

# ====================================================
# GIT
# ====================================================
alias gs="git status"
alias gcam="git commit -a -m"
alias gba="git branch -a"
alias gc="git checkout"
alias gpush="git push origin"
alias gpull="git pull origin"
alias gadd="git add ."

# ====================================================
# WINDOWS SYSTEM CONTROL
# ====================================================
# Shutdown Windows with 15s delay, Ctrl+C to cancel
shutdown() {
    local API="http://${WINDOWS_IP}:7777"

    echo "Initiating shutdown in 15 seconds... (Ctrl+C to cancel)"

    # Request shutdown with 15s delay
    local response=$(curl -s -X POST "$API/api/system/shutdown" \
        -H "Content-Type: application/json" \
        -d '{"action": "shutdown", "delay_seconds": 15}')

    local success=$(echo "$response" | python3 -c "import sys,json; print(json.load(sys.stdin).get('success', False))" 2>/dev/null)

    if [[ "$success" != "True" ]]; then
        echo "Failed to initiate shutdown: $response"
        return 1
    fi

    # Trap Ctrl+C to cancel shutdown
    trap 'echo ""; echo "Cancelling shutdown..."; curl -s -X POST "$API/api/system/shutdown/cancel" | python3 -c "import sys,json; print(json.load(sys.stdin).get(\"message\", \"Unknown\"))"; trap - INT; return 130' INT

    # Countdown
    for i in {15..1}; do
        printf "\rShutdown in %2d seconds... (Ctrl+C to cancel)" "$i"
        sleep 1
    done

    trap - INT
    echo ""
    echo "Shutdown initiated."
}

# ====================================================
# AUTO-SSH TO DESKTOP ON STARTUP
# ====================================================
# Start in SSH session by default. Use 'exit' to access local phone.
ssh-desktop
