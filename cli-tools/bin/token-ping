#!/usr/bin/env python3
"""Hit any Token-API endpoint from the terminal.

Usage:
    token-ping                                     # List all endpoints
    token-ping /health                             # GET /health
    token-ping timer/break                         # Prefix match -> POST /api/timer/break
    token-ping break                               # Suffix match -> /api/timer/break
    token-ping zap type=beep value=75              # POST with query params
    token-ping notify message="hello world"        # POST with JSON body
    token-ping /api/notify -d '{"message":"hi"}'   # Explicit JSON body
    token-ping -X DELETE instances/abc123          # Method override
    token-ping --raw /health                       # Raw JSON (no jq, pipe-friendly)
    token-ping --no-restart /health                # Skip auto-restart

Flags:
    -X METHOD       Override HTTP method
    -d JSON         Explicit JSON body
    --raw           Raw JSON output (no jq colors, pipe-friendly)
    --no-restart    Don't auto-restart server if down
    -h, --help      Show this help
"""

import sys
import json
import time
import os
import subprocess
import urllib.request
import urllib.error
import urllib.parse

API_URL = "http://localhost:7777"

# ANSI colors
RESET = "\033[0m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
BLUE = "\033[34m"
CYAN = "\033[36m"
DIM = "\033[2m"
BOLD = "\033[1m"

METHOD_COLORS = {
    "GET": GREEN,
    "POST": YELLOW,
    "PATCH": BLUE,
    "DELETE": RED,
    "PUT": CYAN,
}


def color(text, code):
    return f"{code}{text}{RESET}"


def ensure_server(skip=False):
    """Check server health, restart if needed. Returns True if healthy."""
    try:
        req = urllib.request.Request(f"{API_URL}/health", method="GET")
        with urllib.request.urlopen(req, timeout=2) as resp:
            return True
    except Exception:
        pass

    if skip:
        print(color("Server not responding", RED), file=sys.stderr)
        sys.exit(1)

    print(color("Server not responding, restarting...", YELLOW), file=sys.stderr)
    subprocess.run(["pkill", "-f", "uvicorn.*7777"], capture_output=True)
    time.sleep(2)

    for i in range(10):
        time.sleep(1)
        try:
            req = urllib.request.Request(f"{API_URL}/health", method="GET")
            with urllib.request.urlopen(req, timeout=2):
                print(color("Server is up", GREEN), file=sys.stderr)
                return True
        except Exception:
            pass
        print(f"  Waiting... ({i + 1}/10)", file=sys.stderr)

    print(color("Server failed to start", RED), file=sys.stderr)
    sys.exit(1)


def load_openapi():
    """Fetch and return parsed OpenAPI schema."""
    try:
        req = urllib.request.Request(f"{API_URL}/openapi.json", method="GET")
        with urllib.request.urlopen(req, timeout=5) as resp:
            return json.loads(resp.read().decode())
    except Exception as e:
        print(color(f"Failed to load OpenAPI schema: {e}", RED), file=sys.stderr)
        sys.exit(1)


def match_template(path, template):
    """Check if concrete path matches a template like /api/instances/{instance_id}.
    Returns True if segments match (with {param} matching anything)."""
    path_parts = path.strip("/").split("/")
    tmpl_parts = template.strip("/").split("/")
    if len(path_parts) != len(tmpl_parts):
        return False
    for p, t in zip(path_parts, tmpl_parts):
        if t.startswith("{") and t.endswith("}"):
            continue
        if p != t:
            return False
    return True


def resolve_endpoint(user_input, paths):
    """3-tier resolution: exact, prefix, suffix. Returns list of (template, methods_dict)."""
    # Normalize: ensure leading slash
    inp = user_input if user_input.startswith("/") else "/" + user_input

    matches = []

    # Tier 1: Exact match (including template matching)
    for tmpl, methods in paths.items():
        if inp == tmpl or match_template(inp, tmpl):
            matches.append((tmpl, methods))
    if matches:
        return matches

    # Tier 2: Prefix — try /api/ prefix
    prefixed = "/api" + inp if not inp.startswith("/api/") else inp
    for tmpl, methods in paths.items():
        if prefixed == tmpl or match_template(prefixed, tmpl):
            matches.append((tmpl, methods))
    if matches:
        return matches

    # Tier 3: Suffix — input matches the tail of a path
    inp_stripped = inp.strip("/")
    inp_parts = inp_stripped.split("/")
    for tmpl, methods in paths.items():
        tmpl_stripped = tmpl.rstrip("/")
        if tmpl_stripped.endswith("/" + inp_stripped):
            matches.append((tmpl, methods))
            continue
        # Template-aware suffix: only if at least one literal segment matches
        tmpl_parts = tmpl.strip("/").split("/")
        if len(inp_parts) <= len(tmpl_parts):
            tail_parts = tmpl_parts[-len(inp_parts):]
            # Require at least one literal (non-template) segment match
            has_literal_match = any(
                not t.startswith("{") and t == p
                for t, p in zip(tail_parts, inp_parts)
            )
            if has_literal_match and match_template(inp_stripped, "/".join(tail_parts)):
                matches.append((tmpl, methods))

    # Deduplicate
    seen = set()
    unique = []
    for tmpl, methods in matches:
        if tmpl not in seen:
            seen.add(tmpl)
            unique.append((tmpl, methods))

    return unique


def select_method(methods_dict, has_body, has_params, override=None):
    """Pick HTTP method. Override wins, then schema-based heuristic."""
    if override:
        return override.upper()

    available = [m.upper() for m in methods_dict.keys() if m != "options"]

    if len(available) == 1:
        return available[0]

    # If body or params provided, prefer mutating methods
    if has_body or has_params:
        for pref in ("POST", "PATCH", "PUT"):
            if pref in available:
                return pref

    if "GET" in available:
        return "GET"

    return available[0]


def coerce_value(val):
    """Coerce string value to appropriate Python type for JSON."""
    if val.lower() == "true":
        return True
    if val.lower() == "false":
        return False
    if val.lower() == "null":
        return None
    try:
        return int(val)
    except ValueError:
        pass
    try:
        return float(val)
    except ValueError:
        pass
    return val


def endpoint_has_request_body(methods_dict, method):
    """Check if endpoint's schema defines a requestBody for the given method."""
    method_lower = method.lower()
    if method_lower not in methods_dict:
        return False
    return "requestBody" in methods_dict[method_lower]


def print_json(data):
    """Pretty-print JSON through jq if available, else json.dumps."""
    text = json.dumps(data, indent=2)
    try:
        proc = subprocess.run(["jq", "."], input=text, capture_output=True, text=True)
        if proc.returncode == 0:
            print(proc.stdout, end="")
            return
    except FileNotFoundError:
        pass
    print(text)


def make_request(url, method, body=None, raw=False):
    """Execute HTTP request and return (status, data)."""
    try:
        req = urllib.request.Request(url, method=method)
        if body is not None:
            req.add_header("Content-Type", "application/json")
            req.data = json.dumps(body).encode() if isinstance(body, dict) else body.encode()
        elif method in ("POST", "PATCH", "PUT"):
            req.add_header("Content-Type", "application/json")
            req.data = b""
        with urllib.request.urlopen(req, timeout=10) as resp:
            raw_body = resp.read().decode()
            if not raw_body or raw_body.strip() == "":
                return resp.status, None
            return resp.status, json.loads(raw_body)
    except urllib.error.HTTPError as e:
        body_text = e.read().decode()
        try:
            data = json.loads(body_text)
        except Exception:
            data = {"detail": body_text}
        return e.code, data
    except Exception as e:
        return 0, {"detail": str(e)}


def build_url(template, user_input, params):
    """Build concrete URL from template, user input, and query params."""
    # Fill in path parameters from user input
    tmpl_parts = template.strip("/").split("/")
    inp_parts = user_input.strip("/").split("/")

    # Try to align input segments with template segments
    concrete_parts = []
    inp_idx = 0
    # Find where user input aligns with template
    # For prefix matches, user input may start partway through
    offset = len(tmpl_parts) - len(inp_parts)
    if offset < 0:
        offset = 0

    for i, t in enumerate(tmpl_parts):
        if t.startswith("{") and t.endswith("}"):
            # Use corresponding segment from user input if available
            src_idx = i - offset
            if 0 <= src_idx < len(inp_parts):
                concrete_parts.append(inp_parts[src_idx])
            else:
                concrete_parts.append(t)  # Leave template placeholder
        else:
            concrete_parts.append(t)

    path = "/" + "/".join(concrete_parts)
    url = f"{API_URL}{path}"
    if params:
        url += "?" + urllib.parse.urlencode(params)
    return url


def format_endpoint_list(openapi):
    """Display all endpoints grouped by path segment."""
    paths = openapi.get("paths", {})

    # Group by second segment (after /api/)
    groups = {}
    for path, methods in paths.items():
        parts = path.strip("/").split("/")
        if len(parts) >= 2 and parts[0] == "api":
            group = parts[1].replace("-", " ").title()
        elif parts[0] in ("health", ""):
            group = "System"
        else:
            group = parts[0].replace("-", " ").title()
        groups.setdefault(group, []).append((path, methods))

    print(f"\n{BOLD}Token-API Endpoints{RESET}\n")

    for group_name in sorted(groups.keys()):
        print(f"  {BOLD}{group_name}{RESET}")
        endpoints = sorted(groups[group_name], key=lambda x: x[0])
        for path, methods in endpoints:
            for method, details in methods.items():
                if method in ("options", "head"):
                    continue
                m = method.upper()
                mc = METHOD_COLORS.get(m, "")
                summary = details.get("summary", "")
                has_body = "requestBody" in details
                body_tag = f"  {DIM}[body]{RESET}" if has_body else ""
                print(f"    {color(m, mc):>20s}  {path:<45s} {DIM}{summary}{RESET}{body_tag}")
        print()


def parse_args(argv):
    """Parse sys.argv into structured args."""
    result = {
        "endpoint": None,
        "method_override": None,
        "explicit_body": None,
        "raw": False,
        "no_restart": False,
        "kv_pairs": [],
    }

    i = 0
    while i < len(argv):
        arg = argv[i]
        if arg in ("-h", "--help"):
            print(__doc__.strip())
            sys.exit(0)
        elif arg == "-X" and i + 1 < len(argv):
            result["method_override"] = argv[i + 1].upper()
            i += 2
        elif arg == "-d" and i + 1 < len(argv):
            result["explicit_body"] = argv[i + 1]
            i += 2
        elif arg == "--raw":
            result["raw"] = True
            i += 1
        elif arg == "--no-restart":
            result["no_restart"] = True
            i += 1
        elif "=" in arg and not arg.startswith("-") and not arg.startswith("/"):
            key, _, val = arg.partition("=")
            result["kv_pairs"].append((key, val))
            i += 1
        elif result["endpoint"] is None:
            result["endpoint"] = arg
            i += 1
        else:
            # Could be a kv pair without = or an unknown flag
            result["kv_pairs"].append((arg, ""))
            i += 1

    return result


def suggest_endpoints(user_input, paths):
    """Find endpoints containing the user input as substring."""
    inp = user_input.lower().strip("/")
    suggestions = []
    for path in paths:
        if inp in path.lower():
            suggestions.append(path)
    return suggestions[:8]


def main():
    args = parse_args(sys.argv[1:])

    # No endpoint = list all endpoints
    if args["endpoint"] is None:
        ensure_server(skip=args["no_restart"])
        openapi = load_openapi()
        format_endpoint_list(openapi)
        return

    ensure_server(skip=args["no_restart"])
    openapi = load_openapi()
    paths = openapi.get("paths", {})

    # Resolve endpoint
    matches = resolve_endpoint(args["endpoint"], paths)

    if not matches:
        suggestions = suggest_endpoints(args["endpoint"], paths)
        print(color(f"No endpoint matching: {args['endpoint']}", RED), file=sys.stderr)
        if suggestions:
            print("\nDid you mean:", file=sys.stderr)
            for s in suggestions:
                print(f"  {s}", file=sys.stderr)
        sys.exit(1)

    if len(matches) > 1:
        print(color(f"Ambiguous: '{args['endpoint']}' matches multiple endpoints:", YELLOW), file=sys.stderr)
        for tmpl, methods in matches:
            method_list = " ".join(m.upper() for m in methods if m not in ("options", "head"))
            print(f"  {tmpl}  [{method_list}]", file=sys.stderr)
        print(f"\nBe more specific.", file=sys.stderr)
        sys.exit(1)

    template, methods_dict = matches[0]

    # Determine body vs query params
    has_kv = bool(args["kv_pairs"])
    has_explicit_body = args["explicit_body"] is not None

    # Pick method
    method = select_method(
        methods_dict,
        has_body=has_explicit_body or has_kv,
        has_params=has_kv,
        override=args["method_override"],
    )

    # Build body or query params from kv pairs
    body = None
    query_params = {}

    if has_explicit_body:
        try:
            body = json.loads(args["explicit_body"])
        except json.JSONDecodeError:
            print(color("Invalid JSON in -d argument", RED), file=sys.stderr)
            sys.exit(1)
    elif has_kv:
        if endpoint_has_request_body(methods_dict, method):
            body = {k: coerce_value(v) for k, v in args["kv_pairs"]}
        else:
            query_params = {k: v for k, v in args["kv_pairs"]}

    url = build_url(template, args["endpoint"], query_params)
    status, data = make_request(url, method, body, raw=args["raw"])

    # Output
    if args["raw"]:
        if data is not None:
            print(json.dumps(data, indent=2))
        sys.exit(0 if 200 <= status < 400 else 1)

    if status == 0:
        print(color(f"Connection failed: {data.get('detail', 'unknown')}", RED), file=sys.stderr)
        sys.exit(1)

    if status >= 400:
        detail = data.get("detail", data) if isinstance(data, dict) else data
        print(color(f"{method} {template} -> {status}", RED), file=sys.stderr)
        if detail:
            print(color(f"  {detail}", RED), file=sys.stderr)
        sys.exit(1)

    # Success
    if data is None or data == {}:
        mc = METHOD_COLORS.get(method, "")
        print(f"{color(method, mc)} {template} -> {color(str(status), GREEN)}")
    else:
        print_json(data)


if __name__ == "__main__":
    main()
