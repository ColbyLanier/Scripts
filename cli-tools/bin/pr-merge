#!/usr/bin/env bash
# PR Merge with Complete Cleanup
# TAGS: git, pr
# AUDIENCE: human, agent
#
# Merges a PR and cleans up the remote branch, local branch, worktree,
# and bash aliases. The final step after a PR is approved.
#
# Usage: pr-merge [PR_NUMBER] [options]
#
# Examples:
#   pr-merge                          # Auto-detect PR from current branch
#   pr-merge 42                       # Merge PR #42
#   pr-merge --squash                 # Squash merge (default)
#   pr-merge --merge                  # Create merge commit
#   pr-merge --no-cleanup             # Merge only, skip cleanup
#   pr-merge --dry-run                # Preview what would happen

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Icons
SEARCH="๐"
MERGE="๐"
CLEANUP="๐งน"
PULL="๐ฅ"
SUCCESS="โ"
ERROR="โ"
WARNING="โ๏ธ"

log() { echo -e "${BLUE}[pr-merge]${NC} $1"; }
info() { echo -e "${CYAN}   $1${NC}"; }
warn() { echo -e "${YELLOW}[pr-merge]${NC} $1"; }
error() { echo -e "${RED}[pr-merge]${NC} $1" >&2; }
success() { echo -e "${GREEN}[pr-merge]${NC} $1"; }

# Defaults
MERGE_METHOD="squash"
NO_CLEANUP=false
SKIP_CONFIRM=false
DRY_RUN=false
PR_NUMBER=""

usage() {
    cat << 'EOF'
PR Merge with Complete Cleanup

Merges a PR and cleans up everything - remote branch, local branch, worktree,
and bash aliases.

Usage: pr-merge [PR_NUMBER] [options]

Arguments:
  PR_NUMBER           PR number to merge (auto-detected if not provided)

Options:
  --squash            Squash and merge (default)
  --merge             Create a merge commit
  --rebase            Rebase and merge
  --no-cleanup        Merge only, skip local cleanup
  -y, --yes           Skip confirmation prompt
  --dry-run           Show what would happen without doing anything
  -h, --help          Show this help

Examples:
  pr-merge                    # Auto-detect and merge current branch's PR
  pr-merge 42                 # Merge PR #42
  pr-merge --merge            # Use merge commit instead of squash
  pr-merge --no-cleanup       # Just merge, don't clean up locally
  pr-merge --dry-run          # Preview the actions

Description:
  1. Detects PR number from current branch if not provided
  2. Shows PR info and asks for confirmation
  3. Merges the PR (squash by default)
  4. Removes the worktree (if in one)
  5. Deletes the local branch
  6. Pulls latest main
  7. Cleans up bash aliases pointing to the worktree

EOF
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        --squash)
            MERGE_METHOD="squash"
            shift
            ;;
        --merge)
            MERGE_METHOD="merge"
            shift
            ;;
        --rebase)
            MERGE_METHOD="rebase"
            shift
            ;;
        --no-cleanup)
            NO_CLEANUP=true
            shift
            ;;
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        [0-9]*)
            if [[ -z "$PR_NUMBER" ]]; then
                PR_NUMBER="$1"
            else
                error "Multiple PR numbers provided"
                exit 1
            fi
            shift
            ;;
        *)
            error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Verify we're in a git repo
if ! git rev-parse --show-toplevel &>/dev/null; then
    error "Must be run from within a git repository"
    exit 1
fi

# Get repo info
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null) || {
    error "Could not determine repository. Make sure you're in a GitHub repo."
    exit 1
}

# Get repo root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Detect PR number if not provided
if [[ -z "$PR_NUMBER" ]]; then
    log "Detecting PR from current branch..."
    PR_NUMBER=$(gh pr view --json number -q '.number' 2>/dev/null) || {
        error "Could not detect PR from current branch. Provide PR number as argument."
        exit 1
    }
fi

# Get PR info
PR_INFO=$(gh pr view "$PR_NUMBER" --json title,headRefName,state,mergeable 2>/dev/null) || {
    error "Could not fetch PR #${PR_NUMBER}. Does it exist?"
    exit 1
}

PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
BRANCH_NAME=$(echo "$PR_INFO" | jq -r '.headRefName')
PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
PR_MERGEABLE=$(echo "$PR_INFO" | jq -r '.mergeable')

# Check if PR is open
if [[ "$PR_STATE" != "OPEN" ]]; then
    error "PR #${PR_NUMBER} is not open (state: ${PR_STATE})"
    exit 1
fi

# Check if PR is mergeable
if [[ "$PR_MERGEABLE" == "CONFLICTING" ]]; then
    error "PR #${PR_NUMBER} has conflicts and cannot be merged"
    exit 1
fi

# Detect if we're in a worktree
IN_WORKTREE=false
WORKTREE_PATH=""
MAIN_WORKTREE_PATH=""

if [[ -f "$REPO_ROOT/.git" ]]; then
    # .git is a file, not a directory - we're in a worktree
    IN_WORKTREE=true
    WORKTREE_PATH="$REPO_ROOT"

    # Get main worktree path
    MAIN_WORKTREE_PATH=$(git worktree list --porcelain | grep -m1 "^worktree " | cut -d' ' -f2)
fi

# Show plan
echo ""
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo " PR Merge Plan"
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo ""
echo "  Repository:    $REPO"
echo "  PR:            #${PR_NUMBER} - ${PR_TITLE}"
echo "  Branch:        ${BRANCH_NAME}"
echo "  Merge method:  ${MERGE_METHOD}"
echo ""

if [[ "$IN_WORKTREE" == "true" ]]; then
    echo "  Context:       Worktree at ${WORKTREE_PATH}"
    echo "  Main repo:     ${MAIN_WORKTREE_PATH}"
else
    echo "  Context:       Regular checkout (not a worktree)"
fi

echo ""

if [[ "$NO_CLEANUP" == "false" ]]; then
    echo "  Actions:"
    echo "    1. Merge PR #${PR_NUMBER} (${MERGE_METHOD})"

    if [[ "$IN_WORKTREE" == "true" ]]; then
        echo "    2. Remove worktree: ${WORKTREE_PATH}"
        echo "    3. Delete remote branch: ${BRANCH_NAME}"
        echo "    4. Delete local branch: ${BRANCH_NAME}"
    else
        echo "    2. Delete remote branch: ${BRANCH_NAME}"
        echo "    3. Checkout main"
        echo "    4. Delete local branch: ${BRANCH_NAME}"
    fi

    echo "    5. Pull latest main"
    echo "    6. Clean up bash aliases"
else
    echo "  Actions:"
    echo "    1. Merge PR #${PR_NUMBER} (${MERGE_METHOD})"

    if [[ "$IN_WORKTREE" == "true" ]]; then
        echo "    (Local cleanup skipped - remote branch NOT deleted)"
    else
        echo "    2. Delete remote branch: ${BRANCH_NAME}"
        echo "    (Local cleanup skipped)"
    fi
fi

echo ""
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo ""

if [[ "$DRY_RUN" == "true" ]]; then
    warn "Dry run - no changes made"
    exit 0
fi

# Confirmation
if [[ "$SKIP_CONFIRM" == "false" ]]; then
    read -p "Proceed with merge? (y/N) " -n 1 -r
    echo ""
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        warn "Aborted by user"
        exit 0
    fi
fi

# Merge the PR
echo ""
log "${MERGE} Merging PR #${PR_NUMBER} (${MERGE_METHOD})..."

# Only use --delete-branch in regular checkout (not worktree)
# In worktree context, gh tries to checkout main which fails
if [[ "$IN_WORKTREE" == "true" ]]; then
    MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" "--${MERGE_METHOD}" 2>&1) || {
        error "Failed to merge PR: $MERGE_OUTPUT"
        exit 1
    }
else
    MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" "--${MERGE_METHOD}" --delete-branch 2>&1) || {
        error "Failed to merge PR: $MERGE_OUTPUT"
        exit 1
    }
fi

success "${SUCCESS} PR merged successfully"
echo ""

# Exit if no cleanup requested
if [[ "$NO_CLEANUP" == "true" ]]; then
    success "Done! (cleanup skipped)"
    exit 0
fi

# Cleanup phase
log "${CLEANUP} Cleaning up..."
echo ""

# Check for uncommitted changes in worktree
if [[ "$IN_WORKTREE" == "true" ]]; then
    cd "$WORKTREE_PATH"
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        warn "${WARNING} Worktree has uncommitted changes. Cleanup aborted."
        warn "Commit or stash your changes first, then run cleanup manually:"
        warn "  cd \"${MAIN_WORKTREE_PATH}\""
        warn "  git worktree remove \"${WORKTREE_PATH}\""
        warn "  git branch -d ${BRANCH_NAME}"
        exit 1
    fi
fi

# Switch context to main worktree if we're in a worktree
if [[ "$IN_WORKTREE" == "true" ]]; then
    cd "$MAIN_WORKTREE_PATH"

    # Remove worktree
    info "Removing worktree: ${WORKTREE_PATH}"
    git worktree remove "$WORKTREE_PATH" 2>/dev/null || {
        warn "Could not remove worktree automatically. Remove manually:"
        warn "  git worktree remove \"${WORKTREE_PATH}\""
    }

    # Delete remote branch (since we didn't use --delete-branch in worktree context)
    info "Deleting remote branch: ${BRANCH_NAME}"
    git push origin --delete "$BRANCH_NAME" 2>/dev/null || {
        warn "Could not delete remote branch ${BRANCH_NAME} (may already be deleted)"
    }

    # Delete local branch
    info "Deleting local branch: ${BRANCH_NAME}"
    git branch -d "$BRANCH_NAME" 2>/dev/null || {
        warn "Could not delete branch ${BRANCH_NAME} (may already be deleted)"
    }
else
    # Regular checkout - switch to main first
    info "Checking out main..."
    git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
        error "Could not checkout main/master branch"
        exit 1
    }

    # Delete local branch
    info "Deleting local branch: ${BRANCH_NAME}"
    git branch -d "$BRANCH_NAME" 2>/dev/null || {
        warn "Could not delete branch ${BRANCH_NAME} (may already be deleted)"
    }
fi

echo ""

# Pull main
log "${PULL} Pulling main..."
MAIN_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
git pull origin "$MAIN_BRANCH" 2>&1 | sed 's/^/   /'

echo ""

# Clean up bash aliases
ALIASES_FILE="$HOME/.bash_aliases"

if [[ -f "$ALIASES_FILE" ]]; then
    # Expected worktree directory pattern
    REPO_NAME=$(basename "$REPO_ROOT")
    PARENT_DIR=$(dirname "$REPO_ROOT")
    WORKTREE_DIR_PATTERN="${PARENT_DIR}/${REPO_NAME}-${BRANCH_NAME}"

    # Check if alias exists
    if grep -q "$WORKTREE_DIR_PATTERN" "$ALIASES_FILE" 2>/dev/null; then
        # Find matching alias lines
        MATCHING_ALIASES=$(grep "$WORKTREE_DIR_PATTERN" "$ALIASES_FILE")

        # Remove matching alias lines
        sed -i "\|${WORKTREE_DIR_PATTERN}|d" "$ALIASES_FILE"

        # Also check for ~/.cd_quick_aliases (used by worktree-setup)
        CD_ALIASES_FILE="$HOME/.cd_quick_aliases"
        if [[ -f "$CD_ALIASES_FILE" ]]; then
            if grep -q "^${BRANCH_NAME}=" "$CD_ALIASES_FILE" 2>/dev/null; then
                sed -i "/^${BRANCH_NAME}=/d" "$CD_ALIASES_FILE"
                info "Removed cd alias: ${BRANCH_NAME}"
            fi
        fi

        log "Removed bash alias(es):"
        echo "$MATCHING_ALIASES" | sed 's/^/   /'

        # Note to user
        echo ""
        warn "Alias removed. Run 'source ~/.bash_aliases' or restart your shell."
    fi
fi

echo ""
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
success "${SUCCESS} Done! Back on ${MAIN_BRANCH}."
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo ""
