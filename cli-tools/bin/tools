#!/usr/bin/env bash
# tools - Tag-based CLI tool browser with directory injection
# TAGS: workflow, system
# AUDIENCE: human, agent
set -euo pipefail

BIN_DIR="$(cd "$(dirname "$0")" && pwd)"
CLI_TOOLS_DIR="$(dirname "$BIN_DIR")"
TAGS_YAML="$CLI_TOOLS_DIR/directory-tags.yaml"

# --- Defaults ---
MODE="agent"          # agent (non-interactive) or human (interactive)
SHOW_TAGS=false
DIR_MODE=false
DIR_PATH=""
FILTER_TAG=""

# --- Usage ---
usage() {
    cat <<'EOF'
tools - Tag-based CLI tool browser

Usage:
  tools                        List all tools grouped by primary tag
  tools <tag>                  Filter by tag (exact match)
  tools <query>               Fuzzy name search, then AI fallback
  tools --tags                 List all available tags with counts
  tools --agent --dir <path>   Output tools for directory's tag set
  tools --human                Enable interactive mode (AI fallback + tool creation)
  tools --help                 This help message

Header format expected in each tool (first 20 lines):
  #!/usr/bin/env bash
  # tool-name - One sentence description
  # TAGS: git, pr, workflow
  # AUDIENCE: human, agent

Options:
  --human        Enable interactive mode
  --agent        Force agent mode (default)
  --tags         List all tags with tool counts
  --dir <path>   Show tools relevant to a directory (uses directory-tags.yaml)
  --help, -h     Show this help
EOF
    exit 0
}

# --- Argument parsing ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h) usage ;;
        --human) MODE="human"; shift ;;
        --agent) MODE="agent"; shift ;;
        --tags) SHOW_TAGS=true; shift ;;
        --dir)
            DIR_MODE=true
            DIR_PATH="${2:-}"
            if [[ -z "$DIR_PATH" ]]; then
                echo "Error: --dir requires a path argument" >&2
                exit 1
            fi
            shift 2
            ;;
        --) shift; break ;;
        -*) echo "Unknown option: $1" >&2; exit 1 ;;
        *) FILTER_TAG="$1"; shift ;;
    esac
done

# --- Scan tools ---
# Populates parallel arrays: TOOL_NAMES, TOOL_DESCS, TOOL_TAGS, TOOL_AUDIENCES
declare -a TOOL_NAMES=()
declare -a TOOL_DESCS=()
declare -a TOOL_TAGS=()
declare -a TOOL_AUDIENCES=()

scan_tools() {
    # Clear arrays in case of repeated calls
    TOOL_NAMES=()
    TOOL_DESCS=()
    TOOL_TAGS=()
    TOOL_AUDIENCES=()

    for filepath in "$BIN_DIR"/*; do
        # Skip directories, non-executable, archive/, and self
        [[ -d "$filepath" ]] && continue
        [[ ! -x "$filepath" ]] && continue
        local name
        name="$(basename "$filepath")"
        [[ "$name" == "tools" ]] && continue

        # Read first 20 lines
        local desc="" tags="" audience=""
        local line_num=0
        while IFS= read -r line && (( line_num < 20 )); do
            (( line_num++ )) || true

            # Description: second comment line with "name - description" pattern
            if [[ $line_num -le 5 && -z "$desc" ]]; then
                # Match "# something - description" or "# description" style
                if [[ "$line" =~ ^#[[:space:]]+[a-zA-Z_-]+[[:space:]]+[-â€“][[:space:]]+(.*) ]]; then
                    desc="${BASH_REMATCH[1]}"
                # Python docstrings: """description or '''description
                elif [[ "$line" =~ ^\"\"\"(.+) ]]; then
                    desc="${BASH_REMATCH[1]}"
                fi
            fi

            # Tags line
            if [[ "$line" =~ ^#[[:space:]]*TAGS:[[:space:]]*(.*) ]]; then
                tags="${BASH_REMATCH[1]}"
                # Normalize: strip spaces around commas
                tags="$(echo "$tags" | sed 's/[[:space:]]*,[[:space:]]*/,/g')"
            fi

            # Audience line
            if [[ "$line" =~ ^#[[:space:]]*AUDIENCE:[[:space:]]*(.*) ]]; then
                audience="${BASH_REMATCH[1]}"
                audience="$(echo "$audience" | sed 's/[[:space:]]*,[[:space:]]*/,/g')"
            fi
        done < "$filepath"

        # Fallback: extract description from comment on line 2 if not matched
        if [[ -z "$desc" ]]; then
            local line2
            line2="$(sed -n '2p' "$filepath")"
            if [[ "$line2" =~ ^#[[:space:]]+(.*) ]]; then
                desc="${BASH_REMATCH[1]}"
            # Python: """desc"""
            elif [[ "$line2" =~ ^\"\"\"(.*) ]]; then
                desc="${BASH_REMATCH[1]}"
            fi
        fi

        TOOL_NAMES+=("$name")
        TOOL_DESCS+=("${desc:-No description}")
        TOOL_TAGS+=("${tags:-}")
        TOOL_AUDIENCES+=("${audience:-}")
    done
}

# --- Helper: get primary tag (first tag) ---
primary_tag() {
    local tags="$1"
    if [[ -z "$tags" ]]; then
        echo "other"
    else
        echo "${tags%%,*}"
    fi
}

# --- Helper: check if tool has a given tag ---
has_tag() {
    local tool_tags="$1" tag="$2"
    local IFS=','
    for t in $tool_tags; do
        if [[ "$t" == "$tag" ]]; then
            return 0
        fi
    done
    return 1
}

# --- Helper: check if tool is agent-visible ---
is_agent_visible() {
    local audience="$1"
    # If no audience specified, visible to all
    if [[ -z "$audience" ]]; then
        return 0
    fi
    # If audience includes "agent", visible
    if has_tag "$audience" "agent"; then
        return 0
    fi
    return 1
}

# --- Compute max name width for alignment ---
max_name_width() {
    local max=0
    local n
    for n in "$@"; do
        if (( ${#n} > max )); then
            max=${#n}
        fi
    done
    echo "$max"
}

# --- Mode: --tags ---
show_tags() {
    scan_tools

    declare -A tag_counts
    local t
    for i in "${!TOOL_NAMES[@]}"; do
        local tags="${TOOL_TAGS[$i]}"
        if [[ -z "$tags" ]]; then
            tag_counts[other]=$(( ${tag_counts[other]+${tag_counts[other]}} + 1 ))
        else
            IFS=',' read -ra _tag_arr <<< "$tags"
            for t in "${_tag_arr[@]}"; do
                tag_counts[$t]=$(( ${tag_counts[$t]+${tag_counts[$t]}} + 1 ))
            done
        fi
    done

    # Sort and display
    local max_tag=0
    for tag in "${!tag_counts[@]}"; do
        if (( ${#tag} > max_tag )); then
            max_tag=${#tag}
        fi
    done

    printf "\n"
    for tag in $(printf '%s\n' "${!tag_counts[@]}" | sort); do
        local count="${tag_counts[$tag]}"
        local label="tools"
        if (( count == 1 )); then
            label="tool"
        fi
        printf "  %-${max_tag}s  %d %s\n" "$tag" "$count" "$label"
    done
    printf "\n"
}

# --- Mode: --dir ---
show_dir_tools() {
    local dir_path="$1"

    # Expand ~ in dir_path for comparison
    dir_path="${dir_path/#\~/$HOME}"
    # Resolve to absolute path
    if [[ -d "$dir_path" ]]; then
        dir_path="$(cd "$dir_path" && pwd)"
    fi

    if [[ ! -f "$TAGS_YAML" ]]; then
        echo "Error: $TAGS_YAML not found" >&2
        exit 1
    fi

    # Parse YAML: find longest prefix match
    local best_match="" best_tags=""
    local current_path="" current_tags=""

    while IFS= read -r line; do
        # Skip comments and blank lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// /}" ]] && continue

        # Directory line: "~/path:"
        if [[ "$line" =~ ^([^:]+):[[:space:]]*$ ]]; then
            current_path="${BASH_REMATCH[1]}"
            # Trim whitespace
            current_path="${current_path## }"
            current_path="${current_path%% }"
            # Expand ~
            current_path="${current_path/#\~/$HOME}"
            continue
        fi

        # Tags line: "  tags: [tag1, tag2, ...]"
        if [[ "$line" =~ tags:[[:space:]]*\[([^]]*)\] ]]; then
            current_tags="${BASH_REMATCH[1]}"
            # Normalize
            current_tags="$(echo "$current_tags" | sed 's/[[:space:]]*,[[:space:]]*/,/g')"

            # Check prefix match: dir_path starts with current_path
            if [[ "$dir_path" == "$current_path" || "$dir_path" == "$current_path"/* ]]; then
                # Longest prefix wins
                if [[ ${#current_path} -gt ${#best_match} ]]; then
                    best_match="$current_path"
                    best_tags="$current_tags"
                fi
            fi
        fi
    done < "$TAGS_YAML"

    if [[ -z "$best_tags" ]]; then
        echo "No directory mapping found for: $dir_path" >&2
        exit 1
    fi

    scan_tools

    # Collect matching tools
    declare -a match_names=()
    declare -a match_descs=()

    local is_all=false
    if has_tag "$best_tags" "all"; then
        is_all=true
    fi

    for i in "${!TOOL_NAMES[@]}"; do
        # In agent mode, skip human-only tools
        if [[ "$MODE" == "agent" ]]; then
            if ! is_agent_visible "${TOOL_AUDIENCES[$i]}"; then
                continue
            fi
        fi

        if $is_all; then
            match_names+=("${TOOL_NAMES[$i]}")
            match_descs+=("${TOOL_DESCS[$i]}")
            continue
        fi

        # Check if tool has any of the directory tags
        local matched=false
        IFS=',' read -ra _dir_tag_arr <<< "$best_tags"
        for dtag in "${_dir_tag_arr[@]}"; do
            if has_tag "${TOOL_TAGS[$i]}" "$dtag"; then
                matched=true
                break
            fi
        done
        if $matched; then
            match_names+=("${TOOL_NAMES[$i]}")
            match_descs+=("${TOOL_DESCS[$i]}")
        fi
    done

    if [[ ${#match_names[@]} -eq 0 ]]; then
        echo "No tools found for directory: $dir_path"
        return
    fi

    # Compute alignment
    local width
    width="$(max_name_width "${match_names[@]}")"

    echo "Available CLI tools:"
    for i in "${!match_names[@]}"; do
        printf "  %-${width}s  - %s\n" "${match_names[$i]}" "${match_descs[$i]}"
    done
}

# --- Mode: list all tools grouped by primary tag ---
show_all_grouped() {
    scan_tools

    # Collect unique primary tags
    declare -A groups  # tag -> indices (space-separated)
    for i in "${!TOOL_NAMES[@]}"; do
        local ptag
        ptag="$(primary_tag "${TOOL_TAGS[$i]}")"
        groups[$ptag]="${groups[$ptag]+${groups[$ptag]}} $i"
    done

    # Sort tags
    local sorted_tags
    sorted_tags="$(printf '%s\n' "${!groups[@]}" | sort)"

    # Compute global max name width
    local width
    width="$(max_name_width "${TOOL_NAMES[@]}")"

    printf "\n"
    while IFS= read -r tag; do
        [[ -z "$tag" ]] && continue
        printf "  %s:\n" "$tag"
        for i in ${groups[$tag]}; do
            printf "    %-${width}s  %s\n" "${TOOL_NAMES[$i]}" "${TOOL_DESCS[$i]}"
        done
        printf "\n"
    done <<< "$sorted_tags"
}

# --- Mode: filter by tag ---
show_by_tag() {
    local filter="$1"
    scan_tools

    # Check if filter matches any tag
    local found=false
    for i in "${!TOOL_NAMES[@]}"; do
        if has_tag "${TOOL_TAGS[$i]}" "$filter"; then
            found=true
            break
        fi
    done

    if ! $found; then
        return 1
    fi

    # Collect matching tools, sub-grouped by their OTHER tags
    declare -A subgroups  # other_tag -> indices
    for i in "${!TOOL_NAMES[@]}"; do
        if ! has_tag "${TOOL_TAGS[$i]}" "$filter"; then
            continue
        fi

        # Find a secondary tag (first tag that isn't the filter)
        local secondary=""
        IFS=',' read -ra _stag_arr <<< "${TOOL_TAGS[$i]}"
        for t in "${_stag_arr[@]}"; do
            if [[ "$t" != "$filter" ]]; then
                secondary="$t"
                break
            fi
        done
        if [[ -z "$secondary" ]]; then
            secondary="$filter"
        fi

        subgroups[$secondary]="${subgroups[$secondary]+${subgroups[$secondary]}} $i"
    done

    local sorted_subs
    sorted_subs="$(printf '%s\n' "${!subgroups[@]}" | sort)"

    local width
    width="$(max_name_width "${TOOL_NAMES[@]}")"

    printf "\n"
    while IFS= read -r stag; do
        [[ -z "$stag" ]] && continue
        printf "  %s:\n" "$stag"
        for i in ${subgroups[$stag]}; do
            printf "    %-${width}s  %s\n" "${TOOL_NAMES[$i]}" "${TOOL_DESCS[$i]}"
        done
        printf "\n"
    done <<< "$sorted_subs"

    return 0
}

# --- Mode: name search ---
name_search() {
    local query="$1"
    scan_tools

    declare -a match_indices=()
    for i in "${!TOOL_NAMES[@]}"; do
        if [[ "${TOOL_NAMES[$i]}" == *"$query"* ]]; then
            match_indices+=("$i")
        fi
    done

    if [[ ${#match_indices[@]} -eq 0 ]]; then
        return 1
    fi

    if [[ ${#match_indices[@]} -le 2 ]]; then
        # Show --help for each match
        for i in "${match_indices[@]}"; do
            local tool="${TOOL_NAMES[$i]}"
            echo "=== $tool ==="
            "$BIN_DIR/$tool" --help 2>&1 || true
            echo ""
        done
    else
        # List with descriptions
        local width
        width="$(max_name_width "${TOOL_NAMES[@]}")"
        printf "\n"
        for i in "${match_indices[@]}"; do
            printf "  %-${width}s  %s\n" "${TOOL_NAMES[$i]}" "${TOOL_DESCS[$i]}"
        done
        printf "\n"
    fi

    return 0
}

# --- AI fallback ---
ai_fallback() {
    local query="$1"

    echo "No tag or name match for '$query'. Asking AI..."
    local ai_result
    ai_result="$(cd "$BIN_DIR" && unset CLAUDECODE && claude -p --model haiku \
        "The user searched for '$query' in these CLI tools: $(ls | tr '\n' ', '). Which tool(s) match what they're looking for? If no existing tool fits, respond with exactly 'NO_MATCH' on its own line and briefly describe what would be needed." 2>&1)" || true

    echo "$ai_result"

    # Human mode: offer tool creation if NO_MATCH
    if [[ "$MODE" == "human" ]]; then
        if echo "$ai_result" | grep -q "NO_MATCH"; then
            echo ""
            read -rp "Do you want to create this tool? Describe it (or 'no' to cancel): " response
            if [[ "$response" != "no" && "$response" != "n" && -n "$response" ]]; then
                (cd "$HOME/Scripts/cli-tools" && unset CLAUDECODE && claude "$response")
            fi
        fi
    fi
}

# --- Main ---
if $SHOW_TAGS; then
    show_tags
    exit 0
fi

if $DIR_MODE; then
    show_dir_tools "$DIR_PATH"
    exit 0
fi

if [[ -z "$FILTER_TAG" ]]; then
    show_all_grouped
    exit 0
fi

# Try tag filter first
if show_by_tag "$FILTER_TAG"; then
    exit 0
fi

# Try name search
if name_search "$FILTER_TAG"; then
    exit 0
fi

# AI fallback
ai_fallback "$FILTER_TAG"
