#!/usr/bin/env bash
# Deploy CLI - wrapper for Claude Code deployment system
#
# Usage: deploy [service] [target] [options]
#
# Services: backend (default), web, widget-proxy, chat-proxy, proxies
# Targets: dev (default), prod, local, debug
# Options: -b/--blocking, -p/--skip-build, -y/--skip-push
#
# Examples:
#   deploy                        # Backend to dev async
#   deploy prod                   # Backend to prod async
#   deploy web                    # Frontend to dev
#   deploy web prod               # Frontend to prod
#   deploy proxies                # Both proxies to dev
#   deploy local                  # Local backend server

set -euo pipefail

DEPLOY_DIR="$HOME/Scripts/cli-tools/src/deploy"

# Check if help is requested
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
Deploy CLI - Claude Code deployment system

Usage: deploy [service] [target] [options]

Services:
  backend             Main application (default if no service specified)
  web, frontend       Widget/frontend application
  widget-proxy        Widget proxy service
  chat-proxy          Google Chat proxy service
  proxies             Both widget-proxy and chat-proxy

Targets (for backend service):
  dev, development    Cloud development deployment (default)
  prod, production    Cloud production deployment
  local               Local continuous server with ngrok
  debug               Local server with debugpy on port 5678

Targets (for web service):
  dev, development    Cloud development deployment (default)
  prod, production    Cloud production deployment
  local               Local backend + frontend (backend in local mode)
  debug               Local backend + frontend (backend in debug mode with debugpy)

Targets (for proxy services):
  dev, development    Development environment (default)
  prod, production    Production environment

Options:
  -b, --blocking      Wait for completion, monitor errors
  -p, --skip-build    Use last built image (skip docker build)
  -y, --skip-push     Use last pushed image (skip build + push)
  -ft                 Run user cleanup (cmlanier) async during deploy
  -pro [email]        Upgrade account to professional tier (default: cmlanier@civicinitiatives.com)

Request Options (for local deployments):
  --request-endpoint <path>     Endpoint to call after health check
  --request-method <method>     HTTP method (default: GET)
  --request-body <json>         Request body as JSON string
  --request-headers <json>      Custom headers as JSON object
  --force-localhost             Use localhost instead of ngrok
  --localhost                   Alias for --force-localhost

One-Shot Testing:
  --one-shot          Start -> health check -> request -> stop
  --test-and-stop     Alias for --one-shot
  --auto-stop         Alias for --one-shot

Frontend Options (for web local):
  --verify            Capture Vite output, verify env vars loaded correctly

Google Chat Testing:
  --google-chat-message <text>  Send test message (auto-configures request)

Examples:
  # Backend deployments
  deploy                        # Dev async deployment
  deploy prod                   # Prod async deployment
  deploy -b                     # Dev blocking (wait for completion)
  deploy prod -b                # Prod blocking
  deploy local                  # Local server (continuous)
  deploy local -b               # Local with health monitoring
  deploy debug                  # Local with debugger

  # Frontend deployments
  deploy web                    # Frontend to dev
  deploy web prod               # Frontend to prod
  deploy web local              # Local backend + frontend
  deploy web local --verify     # Local with env verification
  deploy web debug              # Local backend (debugpy) + frontend

  # Proxy deployments
  deploy widget-proxy           # Widget proxy to dev
  deploy chat-proxy prod        # Chat proxy to prod
  deploy proxies                # Both proxies to dev
  deploy proxies prod           # Both proxies to prod

  # User cleanup (runs async during build)
  deploy -ft                    # Cleanup + dev deploy
  deploy -ft prod               # Cleanup + prod deploy

  # Subscription management
  deploy -pro                   # Upgrade cmlanier@civicinitiatives.com to professional
  deploy -pro user@example.com  # Upgrade specific account to professional

  # Testing
  deploy local -b --google-chat-message "hello"
  deploy local -b --one-shot --google-chat-message "test"

Legacy Syntax (deprecated):
  deploy -l                     # Use: deploy local
  deploy -d                     # Use: deploy debug
EOF
    exit 0
fi

# Require a git repository context
GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null) || {
    echo "Error: must be run from within a git repository" >&2
    exit 1
}

# Two-layer deployment: use current git root if it has a Makefile, otherwise fall back to main project
MAIN_PROJECT="$HOME/ProcAgentDir/ProcurementAgentAI"
if [[ -f "$GIT_ROOT/Makefile" ]]; then
    PROJECT_DIR="$GIT_ROOT"
else
    echo "No Makefile in $GIT_ROOT, using main project..."
    PROJECT_DIR="$MAIN_PROJECT"
fi

# Verify trigger-deploy.js exists
if [[ ! -f "$DEPLOY_DIR/trigger-deploy.js" ]]; then
    echo "Error: Deploy system not found at $DEPLOY_DIR" >&2
    exit 1
fi

# Upgrade account to professional tier
upgrade_to_professional() {
    local email="${1:-cmlanier@civicinitiatives.com}"
    local domain="${email#*@}"

    echo "Upgrading @$domain to professional tier..."

    local sql="UPDATE partners
SET subscription_tier = 'professional',
    subscription_status = CASE
        WHEN subscription_status IN ('pending', 'trial') THEN 'active'
        ELSE subscription_status
    END
WHERE partner_email LIKE '%@$domain';"

    db-query --env dev query --write "$sql"

    echo "✓ Upgrade complete"

    # Verify the update
    local verify_sql="SELECT partner_id, partner_email, subscription_tier, subscription_status FROM partners WHERE partner_email LIKE '%@$domain';"
    echo ""
    echo "Verification:"
    db-query --env dev query "$verify_sql"
}

# Parse service type and flags from arguments
SERVICE=""
ARGS=()
FIRST_ARG_PROCESSED=false
RUN_FT=false
RUN_PRO=false
PRO_EMAIL=""

for arg in "$@"; do
    # Intercept -ft flag (don't pass to deploy-runner)
    if [[ "$arg" == "-ft" ]]; then
        RUN_FT=true
        continue
    fi

    # Intercept -pro flag and optional email argument
    if [[ "$arg" == "-pro" ]]; then
        RUN_PRO=true
        continue
    fi

    # If previous arg was -pro and this looks like an email, capture it
    if [[ "$RUN_PRO" == "true" && "$arg" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        PRO_EMAIL="$arg"
        continue
    fi

    if [[ "$FIRST_ARG_PROCESSED" == "false" && ! "$arg" =~ ^- ]]; then
        case "$arg" in
            web|frontend)
                SERVICE="web"
                FIRST_ARG_PROCESSED=true
                continue
                ;;
            widget-proxy)
                SERVICE="widget-proxy"
                FIRST_ARG_PROCESSED=true
                continue
                ;;
            chat-proxy)
                SERVICE="chat-proxy"
                FIRST_ARG_PROCESSED=true
                continue
                ;;
            proxies)
                SERVICE="proxies"
                FIRST_ARG_PROCESSED=true
                continue
                ;;
            backend)
                SERVICE="backend"
                FIRST_ARG_PROCESSED=true
                continue
                ;;
        esac
    fi
    ARGS+=("$arg")
done

# Execute from the project directory
cd "$PROJECT_DIR"

# Handle -pro flag if set
if [[ "$RUN_PRO" == "true" ]]; then
    if [[ -n "$PRO_EMAIL" ]]; then
        upgrade_to_professional "$PRO_EMAIL"
    else
        upgrade_to_professional
    fi
    exit 0
fi

# Determine environment from remaining args
ENV="development"
for arg in "${ARGS[@]}"; do
    case "$arg" in
        prod|production) ENV="production" ;;
        dev|development) ENV="development" ;;
    esac
done

# Check for local/debug target and --verify flag
TARGET=""
VERIFY_MODE=false
for arg in "${ARGS[@]}"; do
    case "$arg" in
        local) TARGET="local" ;;
        debug) TARGET="debug" ;;
        --verify) VERIFY_MODE=true ;;
    esac
done

# Launch user cleanup in background if -ft flag was set
FT_PID=""
FT_LOG=""
if [[ "$RUN_FT" == "true" ]]; then
    # Map environment to short form for the new CLI
    FT_ENV="dev"
    [[ "$ENV" == "production" ]] && FT_ENV="prod"
    FT_LOG="$PROJECT_DIR/.ft-cleanup.log"

    echo "Starting user cleanup (async, env=$FT_ENV)..."
    UV_NO_SYNC=1 uv run scripts/user_cleanup.py cmlanier@civicinitiatives.com --env "$FT_ENV" \
        > "$FT_LOG" 2>&1 &
    FT_PID=$!
fi

# Helper: wait for -ft cleanup and report result
wait_for_ft() {
    if [[ -n "$FT_PID" ]]; then
        if wait "$FT_PID" 2>/dev/null; then
            echo ""
            echo "User cleanup completed:"
            cat "$FT_LOG"
        else
            echo ""
            echo "WARNING: User cleanup failed (exit $?):"
            cat "$FT_LOG"
        fi
        rm -f "$FT_LOG"
    fi
}

# Handle different service types
case "$SERVICE" in
    web)
        if [[ "$TARGET" == "local" || "$TARGET" == "debug" ]]; then
            SRC_ENV="$PROJECT_DIR/widget/.env.pax-local"
            TARGET_ENV="$PROJECT_DIR/widget/.env"
            STATE_FILE="$PROJECT_DIR/.claude-local-server-state.json"

            if [[ ! -f "$SRC_ENV" ]]; then
                echo "Error: $SRC_ENV not found" >&2
                exit 1
            fi

            echo "Starting local development environment (backend=$TARGET)..."

            # Trap to cleanup on exit (cd to project root for state file)
            trap 'echo "Cleaning up..."; rm -f "'"$TARGET_ENV"'"; cd "'"$PROJECT_DIR"'" && node "$DEPLOY_DIR/stop-local-server.js" 2>/dev/null; exit 0' INT TERM

            # Start backend (local or debug mode)
            echo "Starting backend in $TARGET mode..."
            node "$DEPLOY_DIR/trigger-deploy.js" "$TARGET"

            # Wait for backend health
            echo "Waiting for backend health check..."
            node "$DEPLOY_DIR/wait-for-health.js" http://localhost:8080

            # Try to capture the freshest ngrok URL from the local server state file
            NGROK_URL=""
            if [[ -f "$STATE_FILE" ]]; then
                NGROK_URL=$(node -e "const fs=require('fs');const p=process.argv[1];try{const d=JSON.parse(fs.readFileSync(p,'utf8'));if(d.ngrokUrl){process.stdout.write(d.ngrokUrl);}}catch(e){}" "$STATE_FILE") || NGROK_URL=""
                NGROK_URL="${NGROK_URL//$'\n'/}"
            fi

            # Fallback to querying the local ngrok API directly if needed
            if [[ -z "$NGROK_URL" ]]; then
                NGROK_URL=$(python3 - <<'PY' 2>/dev/null || true
import json
import urllib.request

try:
    with urllib.request.urlopen("http://127.0.0.1:4040/api/tunnels", timeout=2) as resp:
        data = json.load(resp)
    for tunnel in data.get('tunnels', []):
        if tunnel.get('proto') == 'https':
            print(tunnel.get('public_url', ''), end='')
            break
except Exception:
    pass
PY
)
                NGROK_URL="${NGROK_URL//$'\n'/}"
            fi

            # Update ngrok URL in source file (persists for next run)
            if [[ -n "$NGROK_URL" ]]; then
                echo "Updating $SRC_ENV with ngrok URL: $NGROK_URL"
                python3 "$PROJECT_DIR/scripts/update_env_var.py" --file "$SRC_ENV" --var VITE_API_URL --value "$NGROK_URL"
            else
                echo "Warning: Unable to determine ngrok URL; using existing value"
            fi

            CURRENT_API_URL=$(grep -E '^VITE_API_URL=' "$SRC_ENV" | tail -n 1 | cut -d= -f2- || true)
            if [[ -z "$CURRENT_API_URL" ]]; then
                echo "Error: VITE_API_URL is not set in $SRC_ENV"
                exit 1
            fi

            echo "Using API URL: $CURRENT_API_URL"

            # Copy source env to .env for Vite
            echo "Copying $SRC_ENV → $TARGET_ENV"
            cp "$SRC_ENV" "$TARGET_ENV"

            echo "Starting frontend dev server..."

            if [[ "$VERIFY_MODE" == "true" ]]; then
                # Start Vite in background and capture output for verification
                VITE_LOG="$PROJECT_DIR/.vite-startup.log"
                cd "$PROJECT_DIR/widget"
                npm run dev > "$VITE_LOG" 2>&1 &
                VITE_PID=$!

                echo "Waiting for Vite to start (capturing output)..."

                # Wait for port 3000 to be ready (up to 30 seconds)
                for i in {1..30}; do
                    if nc -z localhost 3000 2>/dev/null; then
                        break
                    fi
                    sleep 1
                done

                if ! nc -z localhost 3000 2>/dev/null; then
                    echo "✗ Vite server failed to start on port 3000"
                    cat "$VITE_LOG"
                    kill $VITE_PID 2>/dev/null || true
                    exit 1
                fi

                echo "✓ Vite server ready on http://localhost:3000"

                # Extract env vars from Vite output
                echo ""
                echo "=== Vite Startup Output ==="
                cat "$VITE_LOG"
                echo "==========================="
                echo ""

                # Parse env vars from the [vite.config] Loaded env: line
                if grep -q '\[vite.config\] Loaded env:' "$VITE_LOG"; then
                    ENV_LINE=$(grep '\[vite.config\] Loaded env:' "$VITE_LOG")
                    echo "Env vars loaded by Vite:"
                    echo "$ENV_LINE" | sed 's/.*Loaded env: /  /'
                else
                    echo "⚠ Could not find env vars in Vite output"
                fi

                # Verify the app loads correctly
                echo ""
                echo "Verifying app loads..."
                sleep 2  # Give React a moment to hydrate

                if curl -s http://localhost:3000 | grep -q 'procurement-chat-root\|root\|React'; then
                    echo "✓ App HTML loaded successfully"
                else
                    echo "⚠ Could not verify app HTML (may still be working)"
                fi

                # Capture browser console output
                echo ""
                echo "=== Browser Console Output ==="
                BROWSER_CONSOLE_BIN="$HOME/Scripts/cli-tools/bin/browser-console"
                if [[ -x "$BROWSER_CONSOLE_BIN" ]]; then
                    CONSOLE_OUTPUT=$("$BROWSER_CONSOLE_BIN" http://localhost:3000 --wait 3 2>&1) || true
                    echo "$CONSOLE_OUTPUT"

                    # Check for specific errors
                    if echo "$CONSOLE_OUTPUT" | grep -q '\[error\].*No API URL configured'; then
                        echo ""
                        echo "⚠ WARNING: API URL not configured in browser!"
                        echo "  Check that VITE_API_URL is set in .env before Vite starts"
                    fi
                else
                    echo "(browser-console tool not available - install playwright)"
                fi
                echo "==============================="

                # Verify env vars are set correctly
                echo ""
                echo "=== Environment Verification ==="
                echo "VITE_API_URL: $CURRENT_API_URL"
                echo "VITE_CLERK_PUBLISHABLE_KEY: $(grep -E '^VITE_CLERK_PUBLISHABLE_KEY=' "$TARGET_ENV" | cut -d= -f2- | head -c 20)..."
                echo "VITE_GOOGLE_PROJECT_ID: $(grep -E '^VITE_GOOGLE_PROJECT_ID=' "$TARGET_ENV" | cut -d= -f2-)"
                echo "================================"
                echo ""
                echo "✓ Verification complete - server running in background (PID: $VITE_PID)"
                echo "  To stop: kill $VITE_PID"
                echo "  Log file: $VITE_LOG"

                # Keep running - user can Ctrl+C to stop
                wait $VITE_PID
            else
                echo "Press Ctrl+C to stop both frontend and backend"
                cd "$PROJECT_DIR/widget"
                npm run dev &
                NPM_PID=$!

                # Re-set trap to include npm process cleanup (cd back to project root for state file)
                trap 'echo "Cleaning up..."; kill $NPM_PID 2>/dev/null; rm -f "'"$TARGET_ENV"'"; cd "'"$PROJECT_DIR"'" && node "$DEPLOY_DIR/stop-local-server.js" 2>/dev/null; exit 0' INT TERM

                wait $NPM_PID
            fi
        else
            echo "Deploying frontend to $ENV..."
            exec make deploy-web ENVIRONMENT="$ENV"
        fi
        ;;
    widget-proxy)
        echo "Deploying widget-proxy to $ENV..."
        exec make deploy-widget-proxy ENVIRONMENT="$ENV"
        ;;
    chat-proxy)
        echo "Deploying chat-proxy to $ENV..."
        exec make deploy-chat-proxy ENVIRONMENT="$ENV"
        ;;
    proxies)
        echo "Deploying both proxies to $ENV..."
        make deploy-widget-proxy ENVIRONMENT="$ENV"
        exec make deploy-chat-proxy ENVIRONMENT="$ENV"
        ;;
    *)
        # Default: backend deployment via trigger-deploy.js
        if [[ -n "$FT_PID" ]]; then
            # Can't exec — need to wait for cleanup after deploy finishes
            node "$DEPLOY_DIR/trigger-deploy.js" "${ARGS[@]}"
            DEPLOY_EXIT=$?
            wait_for_ft
            exit $DEPLOY_EXIT
        else
            exec node "$DEPLOY_DIR/trigger-deploy.js" "${ARGS[@]}"
        fi
        ;;
esac
