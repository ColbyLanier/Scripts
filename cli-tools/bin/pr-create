#!/usr/bin/env bash
# PR Create with Review Polling
#
# Creates a pull request and waits for Greptile/Bugbot reviews to complete,
# then outputs the review comments for the caller to address.
#
# Usage: pr-create [gh pr create options]
#
# Examples:
#   pr-create --title "feat: add login" --body "## Summary\n- Added login"
#   pr-create -t "fix: bug" -b "Fixed the thing"
#
# The tool will:
#   1. Create the PR using gh pr create
#   2. Poll for Greptile/Bugbot review comments (up to 15 minutes)
#   3. Output the review comments for you to address

set -euo pipefail

POLL_INTERVAL=30        # seconds between checks
MAX_WAIT_TIME=900       # 15 minutes max wait
REVIEWERS=("greptile-apps" "github-actions" "bugbot")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() { echo -e "${BLUE}[pr-create]${NC} $1"; }
warn() { echo -e "${YELLOW}[pr-create]${NC} $1"; }
error() { echo -e "${RED}[pr-create]${NC} $1" >&2; }
success() { echo -e "${GREEN}[pr-create]${NC} $1"; }

merge_comments_json() {
    local inline_json="$1"
    local issue_json="$2"

    jq -s '
        def ensure_array:
            if . == null then []
            elif type == "array" then .
            else [] end;
        def annotate($kind):
            map(if type == "object" then . + {comment_type: $kind} else . end);
        (.[0] | ensure_array | annotate("inline"))
        +
        (.[1] | ensure_array | annotate("issue"))
    ' \
        <(printf "%s" "$inline_json") \
        <(printf "%s" "$issue_json")
}

# Show help
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
PR Create with Review Polling

Creates a pull request and waits for automated reviews (Greptile, Bugbot)
to complete, then outputs the review comments.

Usage: pr-create [gh pr create options]

Options (passed to gh pr create):
  -t, --title         PR title (required)
  -b, --body          PR body/description
  -B, --base          Base branch (default: main)
  -H, --head          Head branch (default: current branch)
  --draft             Create as draft PR

Additional options:
  --no-wait           Create PR but don't wait for reviews
  --timeout <mins>    Max wait time in minutes (default: 15)
  --merge             Merge current branch into base via worktree-safe squash
  --base <branch>     Base branch for --merge (default: auto-detect or main)
  -h, --help          Show this help

Examples:
  pr-create --title "feat: add auth" --body "Added OAuth support"
  pr-create -t "fix: login bug" -b "Fixed null check" --no-wait
  pr-create -t "refactor: cleanup" -b "Code cleanup" --timeout 10
  pr-create --merge                  # Merge current branch after PR review
  pr-create --merge --base develop   # Merge into specific base branch

Output:
  Returns the automated review comments formatted for easy reading.
  Reviews from: Greptile, Bugbot, GitHub Actions
EOF
    exit 0
fi

# Parse our custom options
NO_WAIT=false
MERGE_MODE=false
TIMEOUT_MINS=15
BASE_BRANCH=""
GH_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-wait)
            NO_WAIT=true
            shift
            ;;
        --timeout)
            TIMEOUT_MINS="$2"
            MAX_WAIT_TIME=$((TIMEOUT_MINS * 60))
            shift 2
            ;;
        --merge)
            MERGE_MODE=true
            shift
            ;;
        --base)
            BASE_BRANCH="$2"
            shift 2
            ;;
        *)
            GH_ARGS+=("$1")
            shift
            ;;
    esac
done

# Worktree-safe merge+cleanup
do_merge() {
    local branch
    branch=$(git branch --show-current)
    if [[ -z "$branch" ]]; then
        error "Cannot determine current branch (detached HEAD?)"
        exit 1
    fi

    # Determine base branch
    local base="$BASE_BRANCH"
    if [[ -z "$base" ]]; then
        # Try to detect from PR
        local repo_slug
        repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)
        if [[ -n "$repo_slug" ]]; then
            base=$(gh pr view "$branch" --repo "$repo_slug" --json baseRefName -q '.baseRefName' 2>/dev/null || true)
        fi
        if [[ -z "$base" ]]; then
            # Fall back to default branch
            base=$(git remote show origin 2>/dev/null | sed -n 's/.*HEAD branch: //p')
            base="${base:-main}"
        fi
    fi

    log "Merging '$branch' into '$base'..."

    # Detect if running from a worktree
    local git_common_dir
    git_common_dir=$(git rev-parse --git-common-dir 2>/dev/null)
    local git_dir
    git_dir=$(git rev-parse --git-dir 2>/dev/null)

    local main_worktree=""
    local is_worktree=false

    if [[ "$git_common_dir" != "$git_dir" ]]; then
        is_worktree=true
        # Main worktree is the parent of .git common dir
        main_worktree=$(git worktree list --porcelain | head -1 | sed 's/^worktree //')
        log "Detected worktree. Main worktree: $main_worktree"
    else
        main_worktree=$(git rev-parse --show-toplevel)
    fi

    # Fetch latest from origin
    git -C "$main_worktree" fetch origin "$base" || {
        error "Failed to fetch origin/$base"
        exit 1
    }

    # Get PR title for commit message
    local pr_title=""
    local repo_slug
    repo_slug=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)
    if [[ -n "$repo_slug" ]]; then
        pr_title=$(gh pr view "$branch" --repo "$repo_slug" --json title -q '.title' 2>/dev/null || true)
    fi
    if [[ -z "$pr_title" ]]; then
        pr_title="Merge branch '$branch'"
    fi

    # Switch to base branch in main worktree and squash-merge
    log "Switching to '$base' in main worktree..."
    git -C "$main_worktree" checkout "$base" || {
        error "Failed to checkout '$base' in main worktree"
        exit 1
    }

    git -C "$main_worktree" pull --ff-only origin "$base" || {
        error "Failed to pull latest '$base'"
        exit 1
    }

    log "Squash-merging '$branch'..."
    git -C "$main_worktree" merge --squash "$branch" || {
        error "Squash merge failed. Resolve conflicts in: $main_worktree"
        exit 1
    }

    git -C "$main_worktree" commit -m "$pr_title" || {
        error "Commit failed"
        exit 1
    }

    log "Pushing '$base' to origin..."
    git -C "$main_worktree" push origin "$base" || {
        error "Failed to push '$base' to origin"
        exit 1
    }

    success "Merged and pushed '$base'"

    # Delete remote branch
    log "Deleting remote branch '$branch'..."
    git push origin --delete "$branch" 2>/dev/null && \
        success "Deleted remote branch '$branch'" || \
        warn "Could not delete remote branch '$branch' (may already be deleted)"

    if [[ "$is_worktree" == "true" ]]; then
        # Prune from main worktree â€” do NOT remove current directory
        git -C "$main_worktree" worktree prune
        echo ""
        success "Done! The worktree for '$branch' is now dangling."
        echo ""
        echo "  >>> Exit this shell session now. <<<"
        echo "  The worktree directory will be cleaned up on prune."
        echo ""
    else
        # Not a worktree, just delete the local branch
        git branch -D "$branch" 2>/dev/null && \
            success "Deleted local branch '$branch'" || \
            warn "Could not delete local branch (you may be on it)"
    fi
}

# Verify we're in a git repo
if ! git rev-parse --show-toplevel &>/dev/null; then
    error "Must be run from within a git repository"
    exit 1
fi

# Handle --merge mode
if [[ "$MERGE_MODE" == "true" ]]; then
    do_merge
    exit 0
fi

# Get repo info
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null) || {
    error "Could not determine repository. Make sure you're in a GitHub repo."
    exit 1
}

log "Creating PR in $REPO..."

# Auto-push if branch has no remote tracking branch
if ! git rev-parse --abbrev-ref '@{upstream}' &>/dev/null; then
    CURRENT_BRANCH=$(git branch --show-current)
    log "Pushing branch to origin..."
    git push -u origin "$CURRENT_BRANCH" || {
        error "Failed to push branch '$CURRENT_BRANCH' to origin"
        exit 1
    }
    success "Pushed '$CURRENT_BRANCH' to origin"
fi

# Create the PR and capture URL
PR_URL=$(gh pr create "${GH_ARGS[@]}" 2>&1) || {
    error "Failed to create PR: $PR_URL"
    exit 1
}

# Extract PR number from URL
PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

if [[ -z "$PR_NUMBER" ]]; then
    error "Could not extract PR number from: $PR_URL"
    exit 1
fi

success "Created PR #$PR_NUMBER: $PR_URL"

if [[ "$NO_WAIT" == "true" ]]; then
    log "Skipping review wait (--no-wait specified)"
    exit 0
fi

log "Waiting for automated reviews (Greptile, Bugbot)..."
log "Polling every ${POLL_INTERVAL}s for up to ${TIMEOUT_MINS} minutes..."

# Poll for reviews
START_TIME=$(date +%s)
FOUND_REVIEWS=false

while true; do
    ELAPSED=$(($(date +%s) - START_TIME))

    if [[ $ELAPSED -ge $MAX_WAIT_TIME ]]; then
        warn "Timeout reached (${TIMEOUT_MINS} minutes). Fetching any available comments..."
        break
    fi

    # Fetch PR comments (inline) and issue comments (general)
    COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
    ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
    ALL_COMMENTS=$(merge_comments_json "$COMMENTS" "$ISSUE_COMMENTS")

    # Check for bot/reviewer comments across all endpoints
    REVIEWERS_JSON=$(printf '%s\n' "${REVIEWERS[@]}" | jq -R . | jq -sc .)

    COMMENT_COUNT=$(printf "%s" "$ALL_COMMENTS" | jq -r --argjson reviewers "$REVIEWERS_JSON" '
        if type != "array" then 0
        else
            [ .[] | select(
                (.user.type == "Bot") or
                (try ((.user.login | ascii_downcase) as $login |
                    any($reviewers[]; . as $r | $login | contains($r | ascii_downcase))) catch false)
            ) ] | length
        end
    ')

    # Also check reviews (not just comments)
    REVIEWS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/reviews" 2>/dev/null || echo "[]")
    REVIEW_API_COUNT=$(printf "%s" "$REVIEWS" | jq -r --argjson reviewers "$REVIEWERS_JSON" '
        if type != "array" then 0
        else
            [ .[] | select(
                (.user.type == "Bot") or
                (try ((.user.login | ascii_downcase) as $login |
                    any($reviewers[]; . as $r | $login | contains($r | ascii_downcase))) catch false)
            ) ] | length
        end
    ')
    REVIEW_COUNT=$((COMMENT_COUNT + REVIEW_API_COUNT))

    if [[ $REVIEW_COUNT -gt 0 ]]; then
        FOUND_REVIEWS=true
        # Wait a bit more in case more comments are coming
        log "Found $REVIEW_COUNT review comment(s), waiting 30s for any additional..."
        sleep 30
        break
    fi

    REMAINING=$(( (MAX_WAIT_TIME - ELAPSED) / 60 ))
    printf "\r${BLUE}[pr-create]${NC} Waiting... (%d min remaining, %d comments found)   " "$REMAINING" "$REVIEW_COUNT"
    sleep "$POLL_INTERVAL"
done

echo "" # New line after progress

# Fetch final comments
log "Fetching review comments..."

COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
ALL_COMMENTS=$(merge_comments_json "$COMMENTS" "$ISSUE_COMMENTS")
REVIEWS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/reviews" 2>/dev/null || echo "[]")

# Output the reviews in a readable format
echo ""
echo "=============================================="
echo "PR #${PR_NUMBER} Automated Review Comments"
echo "=============================================="
echo ""

OUTPUT_COUNT=0
REVIEWERS_JSON=$(printf '%s\n' "${REVIEWERS[@]}" | jq -R . | jq -sc .)

# Process PR and issue comments together (bot users + known reviewers)
REVIEWER_COMMENTS=$(printf "%s" "$ALL_COMMENTS" | jq -r --argjson reviewers "$REVIEWERS_JSON" '
    if type != "array" then empty
    else
        def is_bot:
            (.user.type == "Bot") or
            (try ((.user.login | ascii_downcase) as $login |
                any($reviewers[]; . as $r | $login | contains($r | ascii_downcase))) catch false);
        def format_comment:
            if (.comment_type // "") == "inline" then
                "### \(.user.login) - \(.path // "General"):\(.line // .original_line // "N/A")\n\((.body // "") | gsub("\r\n"; "\n"))\n"
            else
                "### \(.user.login) (General Comment)\n\((.body // "") | gsub("\r\n"; "\n"))\n"
            end;
        .[] | select(is_bot) | format_comment
    end
')

if [[ -n "$REVIEWER_COMMENTS" ]]; then
    echo "$REVIEWER_COMMENTS"
    OUTPUT_COUNT=$((OUTPUT_COUNT + 1))
fi

# Process reviews (bot users + known reviewers)
REVIEWER_REVIEWS=$(printf "%s" "$REVIEWS" | jq -r --argjson reviewers "$REVIEWERS_JSON" '
    if type != "array" then empty
    else
        .[]
        | select(
            (.user.type == "Bot") or
            (try ((.user.login | ascii_downcase) as $login |
                any($reviewers[]; . as $r | $login | contains($r | ascii_downcase))) catch false))
        | select(.body != null and .body != "")
        | "### \(.user.login) - Review (\(.state))\n\((.body // "") | gsub("\r\n"; "\n"))\n"
    end
')

if [[ -n "$REVIEWER_REVIEWS" ]]; then
    echo "$REVIEWER_REVIEWS"
    OUTPUT_COUNT=$((OUTPUT_COUNT + 1))
fi

if [[ $OUTPUT_COUNT -eq 0 ]]; then
    warn "No automated review comments found."
    echo ""
    echo "This could mean:"
    echo "  - Reviews are still processing"
    echo "  - No issues were found"
    echo "  - Reviewers are not configured for this repo"
    echo ""
    echo "You can manually check: $PR_URL"
fi

echo ""
echo "=============================================="
echo "PR URL: $PR_URL"
echo "=============================================="
