#!/usr/bin/env bash
# PR Create with Review Polling
#
# Creates a pull request and waits for Greptile/Bugbot reviews to complete,
# then outputs the review comments for the caller to address.
#
# Usage: pr-create [gh pr create options]
#
# Examples:
#   pr-create --title "feat: add login" --body "## Summary\n- Added login"
#   pr-create -t "fix: bug" -b "Fixed the thing"
#
# The tool will:
#   1. Create the PR using gh pr create
#   2. Poll for Greptile/Bugbot review comments (up to 15 minutes)
#   3. Output the review comments for you to address

set -euo pipefail

POLL_INTERVAL=30        # seconds between checks
MAX_WAIT_TIME=900       # 15 minutes max wait
REVIEWERS=("greptile-apps" "github-actions" "bugbot")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() { echo -e "${BLUE}[pr-create]${NC} $1"; }
warn() { echo -e "${YELLOW}[pr-create]${NC} $1"; }
error() { echo -e "${RED}[pr-create]${NC} $1" >&2; }
success() { echo -e "${GREEN}[pr-create]${NC} $1"; }

# Show help
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
PR Create with Review Polling

Creates a pull request and waits for automated reviews (Greptile, Bugbot)
to complete, then outputs the review comments.

Usage: pr-create [gh pr create options]

Options (passed to gh pr create):
  -t, --title         PR title (required)
  -b, --body          PR body/description
  -B, --base          Base branch (default: main)
  -H, --head          Head branch (default: current branch)
  --draft             Create as draft PR

Additional options:
  --no-wait           Create PR but don't wait for reviews
  --timeout <mins>    Max wait time in minutes (default: 15)
  -h, --help          Show this help

Examples:
  pr-create --title "feat: add auth" --body "Added OAuth support"
  pr-create -t "fix: login bug" -b "Fixed null check" --no-wait
  pr-create -t "refactor: cleanup" -b "Code cleanup" --timeout 10

Output:
  Returns the automated review comments formatted for easy reading.
  Reviews from: Greptile, Bugbot, GitHub Actions
EOF
    exit 0
fi

# Parse our custom options
NO_WAIT=false
TIMEOUT_MINS=15
GH_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --no-wait)
            NO_WAIT=true
            shift
            ;;
        --timeout)
            TIMEOUT_MINS="$2"
            MAX_WAIT_TIME=$((TIMEOUT_MINS * 60))
            shift 2
            ;;
        *)
            GH_ARGS+=("$1")
            shift
            ;;
    esac
done

# Verify we're in a git repo
if ! git rev-parse --show-toplevel &>/dev/null; then
    error "Must be run from within a git repository"
    exit 1
fi

# Get repo info
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null) || {
    error "Could not determine repository. Make sure you're in a GitHub repo."
    exit 1
}

log "Creating PR in $REPO..."

# Create the PR and capture URL
PR_URL=$(gh pr create "${GH_ARGS[@]}" 2>&1) || {
    error "Failed to create PR: $PR_URL"
    exit 1
}

# Extract PR number from URL
PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

if [[ -z "$PR_NUMBER" ]]; then
    error "Could not extract PR number from: $PR_URL"
    exit 1
fi

success "Created PR #$PR_NUMBER: $PR_URL"

if [[ "$NO_WAIT" == "true" ]]; then
    log "Skipping review wait (--no-wait specified)"
    exit 0
fi

log "Waiting for automated reviews (Greptile, Bugbot)..."
log "Polling every ${POLL_INTERVAL}s for up to ${TIMEOUT_MINS} minutes..."

# Poll for reviews
START_TIME=$(date +%s)
FOUND_REVIEWS=false

while true; do
    ELAPSED=$(($(date +%s) - START_TIME))

    if [[ $ELAPSED -ge $MAX_WAIT_TIME ]]; then
        warn "Timeout reached (${TIMEOUT_MINS} minutes). Fetching any available comments..."
        break
    fi

    # Fetch PR comments
    COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")

    # Also fetch issue comments (some bots post there)
    ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")

    # Check for review comments from our reviewers
    REVIEW_COUNT=0
    for reviewer in "${REVIEWERS[@]}"; do
        # Check PR review comments
        COUNT=$(echo "$COMMENTS" | jq --arg r "$reviewer" '[.[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase))] | length')
        REVIEW_COUNT=$((REVIEW_COUNT + COUNT))

        # Check issue comments
        COUNT=$(echo "$ISSUE_COMMENTS" | jq --arg r "$reviewer" '[.[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase))] | length')
        REVIEW_COUNT=$((REVIEW_COUNT + COUNT))
    done

    # Also check for reviews (not just comments)
    REVIEWS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/reviews" 2>/dev/null || echo "[]")
    for reviewer in "${REVIEWERS[@]}"; do
        COUNT=$(echo "$REVIEWS" | jq --arg r "$reviewer" '[.[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase))] | length')
        REVIEW_COUNT=$((REVIEW_COUNT + COUNT))
    done

    if [[ $REVIEW_COUNT -gt 0 ]]; then
        FOUND_REVIEWS=true
        # Wait a bit more in case more comments are coming
        log "Found $REVIEW_COUNT review comment(s), waiting 30s for any additional..."
        sleep 30
        break
    fi

    REMAINING=$(( (MAX_WAIT_TIME - ELAPSED) / 60 ))
    printf "\r${BLUE}[pr-create]${NC} Waiting... (%d min remaining, %d comments found)   " "$REMAINING" "$REVIEW_COUNT"
    sleep "$POLL_INTERVAL"
done

echo "" # New line after progress

# Fetch final comments
log "Fetching review comments..."

COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
REVIEWS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/reviews" 2>/dev/null || echo "[]")

# Output the reviews in a readable format
echo ""
echo "=============================================="
echo "PR #${PR_NUMBER} Automated Review Comments"
echo "=============================================="
echo ""

OUTPUT_COUNT=0

# Process PR review comments (inline comments)
for reviewer in "${REVIEWERS[@]}"; do
    REVIEWER_COMMENTS=$(echo "$COMMENTS" | jq -r --arg r "$reviewer" '
        .[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase)) |
        "### \(.user.login) - \(.path):\(.line // .original_line // "N/A")\n\(.body)\n"
    ')

    if [[ -n "$REVIEWER_COMMENTS" ]]; then
        echo "$REVIEWER_COMMENTS"
        OUTPUT_COUNT=$((OUTPUT_COUNT + 1))
    fi
done

# Process issue comments (general comments)
for reviewer in "${REVIEWERS[@]}"; do
    REVIEWER_COMMENTS=$(echo "$ISSUE_COMMENTS" | jq -r --arg r "$reviewer" '
        .[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase)) |
        "### \(.user.login) (General Comment)\n\(.body)\n"
    ')

    if [[ -n "$REVIEWER_COMMENTS" ]]; then
        echo "$REVIEWER_COMMENTS"
        OUTPUT_COUNT=$((OUTPUT_COUNT + 1))
    fi
done

# Process reviews
for reviewer in "${REVIEWERS[@]}"; do
    REVIEWER_REVIEWS=$(echo "$REVIEWS" | jq -r --arg r "$reviewer" '
        .[] | select(.user.login | ascii_downcase | contains($r | ascii_downcase)) |
        select(.body != null and .body != "") |
        "### \(.user.login) - Review (\(.state))\n\(.body)\n"
    ')

    if [[ -n "$REVIEWER_REVIEWS" ]]; then
        echo "$REVIEWER_REVIEWS"
        OUTPUT_COUNT=$((OUTPUT_COUNT + 1))
    fi
done

if [[ $OUTPUT_COUNT -eq 0 ]]; then
    warn "No automated review comments found."
    echo ""
    echo "This could mean:"
    echo "  - Reviews are still processing"
    echo "  - No issues were found"
    echo "  - Reviewers are not configured for this repo"
    echo ""
    echo "You can manually check: $PR_URL"
fi

echo ""
echo "=============================================="
echo "PR URL: $PR_URL"
echo "=============================================="
