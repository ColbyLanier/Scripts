#!/bin/bash
# ssh-connect - Standardized SSH with auto-close redirect
# TAGS: ssh, network
# AUDIENCE: human
# Usage: ssh-connect <mac|wsl|phone> [--proxy] [command...]
#
# When in an SSH session, instead of nesting (origin→A→target), this:
#   1. Writes redirect file on origin via reverse SSH
#   2. Exits current session (returns to origin)
#   3. Origin's wrapper loop picks up redirect and connects directly
#
# Use --proxy to skip redirect and nest normally.

set -e

# Map target name to SSH host alias (from ~/.ssh/config)
target_to_host() {
    case "$1" in
        mac)   echo "mini" ;;
        wsl)   echo "wsl" ;;
        phone) echo "phone" ;;
        *)     echo "" ;;
    esac
}

# Map Tailscale IP to host alias (for reverse SSH to origin)
ip_to_host() {
    case "$1" in
        100.95.109.23)  echo "mini" ;;
        100.69.198.87)  echo "desktop" ;;
        100.66.10.74)   echo "wsl" ;;
        100.102.92.24)  echo "phone" ;;
        *)              echo "" ;;
    esac
}

if [[ -z "$1" ]]; then
    echo "Usage: ssh-connect <mac|wsl|phone> [--proxy] [command...]"
    exit 1
fi

TARGET="$1"; shift

PROXY=false
if [[ "$1" == "--proxy" ]]; then
    PROXY=true
    shift
fi

HOST=$(target_to_host "$TARGET")
if [[ -z "$HOST" ]]; then
    echo "Unknown target: $TARGET (expected mac, wsl, or phone)"
    exit 1
fi

# --- Redirect-on-exit: if in SSH session and not --proxy ---
if [[ -n "$SSH_CONNECTION" ]] && ! $PROXY; then
    origin_ip="${SSH_CLIENT%% *}"
    origin_host=$(ip_to_host "$origin_ip")
    if [[ -n "$origin_host" ]]; then
        echo "Redirecting: closing this session → connecting to $TARGET from origin..."
        if ssh -o ConnectTimeout=3 -o BatchMode=yes "$origin_host" \
            "echo $TARGET > \$HOME/.ssh-next" 2>/dev/null; then
            # Kill the parent shell to close the SSH session automatically.
            # $PPID is the interactive login shell spawned by sshd.
            kill -HUP $PPID 2>/dev/null
            exit 0
        fi
        echo "Reverse SSH to origin failed, falling back to direct connection..."
    fi
    # Fallback: if reverse SSH fails, replace session directly
    echo "Redirect failed, replacing session..."
    exec ssh "$HOST" "$@"
fi

# --- Direct connection (not in SSH session) ---
# Wrapper loop: after SSH exits, check for redirect file
while true; do
    if [[ $# -gt 0 ]]; then
        ssh "$HOST" -t "$*"
        break  # No redirect loop for command mode
    else
        ssh "$HOST"
    fi

    # Check for redirect from a nested session
    if [[ -f ~/.ssh-next ]]; then
        next=$(cat ~/.ssh-next)
        rm -f ~/.ssh-next
        HOST=$(target_to_host "$next")
        TARGET="$next"
        if [[ -z "$HOST" ]]; then
            echo "Invalid redirect target: $next"
            break
        fi
        echo "Redirecting to $TARGET..."
    else
        break
    fi
done
