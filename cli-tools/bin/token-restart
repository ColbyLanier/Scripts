#!/usr/bin/env bash
# token-restart - Restart the Token-API server
#
# Usage:
#   token-restart              # Restart server via systemd
#   token-restart --kill       # Just kill, don't restart
#   token-restart --watch      # Restart and monitor startup
#   token-restart --status     # Show current status only
#
# The server runs on port 7777 and is managed by systemd (token-api.service)

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

show_help() {
    cat << 'EOF'
token-restart - Restart the Token-API server

Usage:
    token-restart              Restart server (no sudo needed)
    token-restart --kill       Kill process (systemd auto-restarts in ~5s)
    token-restart --watch      Restart and monitor startup logs
    token-restart --status     Show current server status only
    token-restart -h, --help   Show this help

Examples:
    token-restart              # Quick restart
    token-restart --watch      # Restart and tail logs
    token-restart --status     # Check if running

Notes:
    - Server runs on port 7777
    - Uses pkill + systemd auto-restart (no sudo needed)
    - Logs available via: journalctl -u token-api -f
EOF
}

check_health() {
    if curl -sf http://localhost:7777/health > /dev/null 2>&1; then
        echo -e "${GREEN}●${NC} Server is healthy"
        return 0
    else
        echo -e "${RED}●${NC} Server is not responding"
        return 1
    fi
}

get_status() {
    echo "=== Token-API Status ==="

    # Check systemd status
    if systemctl is-active --quiet token-api 2>/dev/null; then
        echo -e "Systemd: ${GREEN}active${NC}"
    else
        echo -e "Systemd: ${RED}inactive${NC}"
    fi

    # Check process
    local pid
    pid=$(pgrep -f 'uvicorn.*7777' 2>/dev/null || true)
    if [[ -n "$pid" ]]; then
        echo -e "Process: ${GREEN}running${NC} (PID: $pid)"
    else
        echo -e "Process: ${RED}not running${NC}"
    fi

    # Health check
    check_health
}

kill_server() {
    echo "Stopping Token-API..."

    # Kill the process (no sudo needed)
    if pkill -f 'uvicorn.*7777' 2>/dev/null; then
        echo "Killed uvicorn process"
    else
        echo "No process found"
    fi

    sleep 1

    if pgrep -f 'uvicorn.*7777' > /dev/null 2>&1; then
        echo -e "${YELLOW}Warning: Process still running, force killing...${NC}"
        pkill -9 -f 'uvicorn.*7777' 2>/dev/null || true
    fi

    echo -e "${GREEN}Server stopped${NC}"
    echo "Note: systemd will auto-restart in ~5s unless you 'sudo systemctl stop token-api'"
}

restart_server() {
    echo "Restarting Token-API..."

    # Kill process - systemd will auto-restart (Restart=always, RestartSec=5)
    # This avoids needing sudo for systemctl restart
    if pgrep -f 'uvicorn.*7777' > /dev/null 2>&1; then
        pkill -f 'uvicorn.*7777' 2>/dev/null || true
        echo "Killed old process, waiting for systemd to restart..."
    else
        echo "No process running, starting fresh..."
    fi

    # Wait for systemd to restart (RestartSec=5)
    sleep 2

    # Wait for startup
    local attempts=0
    local max_attempts=10

    while [[ $attempts -lt $max_attempts ]]; do
        sleep 1
        if curl -sf http://localhost:7777/health > /dev/null 2>&1; then
            echo -e "${GREEN}Server is up and healthy${NC}"
            return 0
        fi
        attempts=$((attempts + 1))
        echo "  Waiting... ($attempts/$max_attempts)"
    done

    echo -e "${RED}Server failed to start within ${max_attempts}s${NC}"
    echo "Check logs: journalctl -u token-api -n 50"
    return 1
}

watch_logs() {
    echo "Tailing logs (Ctrl+C to stop)..."
    journalctl -u token-api -f --no-pager
}

# Parse arguments
ACTION="restart"

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        --kill)
            ACTION="kill"
            shift
            ;;
        --watch)
            ACTION="watch"
            shift
            ;;
        --status)
            ACTION="status"
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage" >&2
            exit 1
            ;;
    esac
done

# Execute action
case "$ACTION" in
    status)
        get_status
        ;;
    kill)
        kill_server
        ;;
    watch)
        restart_server
        watch_logs
        ;;
    restart)
        restart_server
        ;;
esac
