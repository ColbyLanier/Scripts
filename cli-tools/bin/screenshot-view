#!/usr/bin/env bash
# screenshot-view - Terminal slideshow viewer for Puppeteer E2E screenshots
# TAGS: dev, screenshot, viewer
# AUDIENCE: human
#
# Watches /tmp/e2e-screenshots/ (or a given directory) for new PNG files and
# displays them in the terminal. Arrow keys to navigate, auto-refreshes when
# new screenshots appear.
#
# Usage: screenshot-view [directory]
#
# Renderer detection order:
#   1. imgcat  (iTerm2 / WSL iterm protocol)
#   2. chafa   (symbols/iterm — best WSL2 support; auto-installs if missing)
#   3. viu     (kitty / sixel / blocks)
#   4. fallback listing (path + metadata only)
#
# Dependencies (auto-installed if missing): chafa, inotify-tools

set -euo pipefail

# ── Constants ────────────────────────────────────────────────────────────────

DEFAULT_DIR="/tmp/e2e-screenshots"
POLL_INTERVAL=1        # seconds between directory polls when inotifywait absent
WATCH_TIMEOUT=2        # seconds inotifywait blocks before we re-check

# ── Colors / UI ──────────────────────────────────────────────────────────────

BOLD='\033[1m'
DIM='\033[2m'
CYAN='\033[0;36m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m'

log()  { printf "${CYAN}[screenshot-view]${NC} %s\n" "$1" >&2; }
warn() { printf "${YELLOW}[screenshot-view]${NC} %s\n" "$1" >&2; }
error(){ printf "${RED}[screenshot-view]${NC} %s\n" "$1" >&2; }

# ── Help ─────────────────────────────────────────────────────────────────────

if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
screenshot-view - Terminal slideshow viewer for E2E screenshots

Usage: screenshot-view [directory]

Arguments:
  directory   Directory to watch (default: /tmp/e2e-screenshots/)

Navigation:
  ← / h       Previous screenshot
  → / l       Next screenshot
  r           Reload / force redraw
  q / Ctrl-C  Quit

Renderer (auto-selected):
  imgcat      iTerm2 inline image protocol
  chafa       Symbol/iterm rendering (auto-installed if missing; best for WSL2)
  viu         Kitty/sixel/block rendering
  fallback    File listing with metadata (no image rendering)

The viewer auto-refreshes within 2s when a new screenshot is saved to the
watched directory. Most useful while running `screenshot` or E2E tests.

Examples:
  screenshot-view
  screenshot-view /tmp/e2e-screenshots
  screenshot-view ~/my-screenshots
EOF
    exit 0
fi

# ── Argument parsing ─────────────────────────────────────────────────────────

WATCH_DIR="${1:-$DEFAULT_DIR}"
WATCH_DIR="${WATCH_DIR%/}"   # strip trailing slash

# ── Dependency checks / installation ────────────────────────────────────────

RENDERER=""

detect_renderer() {
    if command -v imgcat >/dev/null 2>&1; then
        RENDERER="imgcat"
    elif command -v chafa >/dev/null 2>&1; then
        RENDERER="chafa"
    elif command -v viu >/dev/null 2>&1; then
        RENDERER="viu"
    else
        RENDERER="fallback"
    fi
}

try_install_chafa() {
    # Attempt a silent apt-get install; don't abort if it fails
    if command -v apt-get >/dev/null 2>&1; then
        log "chafa not found — attempting: sudo apt-get install -y chafa"
        if sudo apt-get install -y chafa >/dev/null 2>&1; then
            log "chafa installed successfully"
            return 0
        else
            warn "Could not install chafa automatically (may need sudo password)"
            return 1
        fi
    fi
    return 1
}

try_install_inotify() {
    if command -v apt-get >/dev/null 2>&1; then
        log "inotifywait not found — attempting: sudo apt-get install -y inotify-tools"
        if sudo apt-get install -y inotify-tools >/dev/null 2>&1; then
            log "inotify-tools installed successfully"
            return 0
        else
            warn "Could not install inotify-tools automatically — falling back to polling"
            return 1
        fi
    fi
    return 1
}

# First renderer detection pass
detect_renderer

# If no renderer and chafa is installable, try installing it
if [[ "$RENDERER" == "fallback" ]]; then
    if try_install_chafa; then
        detect_renderer
    fi
fi

# inotifywait detection / installation
HAS_INOTIFY=false
if command -v inotifywait >/dev/null 2>&1; then
    HAS_INOTIFY=true
else
    if try_install_inotify; then
        HAS_INOTIFY=true
    fi
fi

# ── chafa format detection ───────────────────────────────────────────────────

# Choose best chafa format for current terminal.
# In tmux/screen the $TERM is overridden; check $TERM_PROGRAM / $WT_SESSION too.
CHAFA_FORMAT="symbols"

if [[ "$RENDERER" == "chafa" ]]; then
    # Windows Terminal supports iterm; most others use symbols
    if [[ -n "${WT_SESSION:-}" ]]; then
        CHAFA_FORMAT="iterm"
    elif [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]]; then
        CHAFA_FORMAT="iterm"
    elif [[ "${TERM_PROGRAM:-}" == "WezTerm" ]] || [[ "${TERM_PROGRAM:-}" == "Hyper" ]]; then
        CHAFA_FORMAT="iterm"
    fi
fi

# ── Terminal helpers ─────────────────────────────────────────────────────────

clear_screen() {
    tput clear 2>/dev/null || printf '\033[2J\033[H'
}

move_cursor_home() {
    tput cup 0 0 2>/dev/null || printf '\033[H'
}

term_cols() {
    tput cols 2>/dev/null || echo 80
}

term_lines() {
    tput lines 2>/dev/null || echo 24
}

separator() {
    local cols
    cols=$(term_cols)
    printf '%*s\n' "$cols" '' | tr ' ' '─'
}

hide_cursor() {
    tput civis 2>/dev/null || true
}

show_cursor() {
    tput cnorm 2>/dev/null || true
}

# ── Screenshot list management ───────────────────────────────────────────────

# Global arrays (bash 4+)
declare -a FILES=()
CURRENT_INDEX=0

refresh_file_list() {
    local old_count=${#FILES[@]}

    # Read PNG files sorted by modification time (oldest first → newest last)
    mapfile -t FILES < <(
        find "$WATCH_DIR" -maxdepth 1 -name "*.png" -printf '%T@ %p\n' 2>/dev/null \
            | sort -n \
            | awk '{print $2}'
    )

    local new_count=${#FILES[@]}

    # If new files appeared, jump to the latest one
    if (( new_count > old_count )); then
        CURRENT_INDEX=$(( new_count - 1 ))
        return 0    # signal: list changed
    fi
    return 1        # no change
}

# ── Image rendering ──────────────────────────────────────────────────────────

render_image() {
    local file="$1"

    # Reserve top 4 lines for header + footer 3 lines at bottom
    local available_lines
    available_lines=$(( $(term_lines) - 7 ))
    local cols
    cols=$(term_cols)

    case "$RENDERER" in
        imgcat)
            imgcat --width "$cols" "$file" 2>/dev/null || true
            ;;
        chafa)
            chafa \
                --format "$CHAFA_FORMAT" \
                --size "${cols}x${available_lines}" \
                --stretch \
                "$file" 2>/dev/null || true
            ;;
        viu)
            viu --width "$cols" --height "$available_lines" "$file" 2>/dev/null || true
            ;;
        fallback)
            local size
            size=$(du -sh "$file" 2>/dev/null | cut -f1)
            local mtime
            mtime=$(stat --format='%y' "$file" 2>/dev/null | cut -d'.' -f1)
            printf "\n"
            printf "  ${BOLD}File:${NC}  %s\n" "$(basename "$file")"
            printf "  ${BOLD}Path:${NC}  %s\n" "$file"
            printf "  ${BOLD}Size:${NC}  %s\n" "$size"
            printf "  ${BOLD}Time:${NC}  %s\n" "$mtime"
            printf "\n"
            printf "  ${DIM}(No image renderer available — see screenshot-view --help)${NC}\n"
            printf "\n"
            ;;
    esac
}

# ── Header / footer ──────────────────────────────────────────────────────────

draw_header() {
    local total=${#FILES[@]}
    local idx=$(( CURRENT_INDEX + 1 ))
    local watch_status
    if $HAS_INOTIFY; then
        watch_status="${GREEN}watching${NC}"
    else
        watch_status="${YELLOW}polling ${POLL_INTERVAL}s${NC}"
    fi

    printf "${BOLD}Screenshot Viewer${NC} | %s [%b]\n" "$WATCH_DIR" "$watch_status"
    separator

    if (( total == 0 )); then
        printf "  ${DIM}(no screenshots yet)${NC}\n"
    else
        local fname
        fname=$(basename "${FILES[$CURRENT_INDEX]}")
        printf "  ${BOLD}%s${NC}  ${DIM}(%d/%d)${NC}\n" "$fname" "$idx" "$total"
    fi

    separator
}

draw_footer() {
    separator
    local renderer_label="renderer: ${RENDERER}"
    if [[ "$RENDERER" == "chafa" ]]; then
        renderer_label="renderer: chafa (${CHAFA_FORMAT})"
    fi
    printf "  ${DIM}← prev  → next  r reload  q quit  |  %s${NC}\n" "$renderer_label"
}

draw_frame() {
    clear_screen
    draw_header

    if (( ${#FILES[@]} > 0 )); then
        render_image "${FILES[$CURRENT_INDEX]}"
    fi

    draw_footer
}

# ── Directory watch loop ──────────────────────────────────────────────────────

# Background watcher: writes a single byte to a pipe when new files appear.
# Main loop reads the pipe in non-blocking mode.
WATCH_PIPE=""
WATCH_PID=""

start_watcher() {
    WATCH_PIPE=$(mktemp -u /tmp/screenshot-view-pipe.XXXXXX)
    mkfifo "$WATCH_PIPE"

    if $HAS_INOTIFY; then
        (
            # Re-open the pipe in subshell so writes don't block on no-reader
            exec 3>"$WATCH_PIPE"
            while true; do
                inotifywait -q -e close_write,moved_to,create \
                    --timeout "$WATCH_TIMEOUT" \
                    "$WATCH_DIR" >/dev/null 2>&1 || true
                printf 'n' >&3
            done
        ) &
        WATCH_PID=$!
    else
        (
            exec 3>"$WATCH_PIPE"
            local last_count=0
            while true; do
                sleep "$POLL_INTERVAL"
                local count
                count=$(find "$WATCH_DIR" -maxdepth 1 -name "*.png" 2>/dev/null | wc -l)
                if (( count != last_count )); then
                    last_count=$count
                    printf 'n' >&3
                fi
            done
        ) &
        WATCH_PID=$!
    fi
}

stop_watcher() {
    if [[ -n "$WATCH_PID" ]]; then
        kill "$WATCH_PID" 2>/dev/null || true
    fi
    if [[ -n "$WATCH_PIPE" ]] && [[ -e "$WATCH_PIPE" ]]; then
        rm -f "$WATCH_PIPE"
    fi
}

# ── Keyboard input ────────────────────────────────────────────────────────────

# Read a single keypress (raw mode).  Returns the key name.
read_key() {
    local key
    IFS= read -r -s -n1 -t 0.1 key 2>/dev/null || true

    if [[ "$key" == $'\x1b' ]]; then
        # Possible escape sequence (arrow keys)
        local seq
        IFS= read -r -s -n2 -t 0.05 seq 2>/dev/null || true
        key="${key}${seq}"
    fi

    case "$key" in
        $'\x1b[D' | h | H) echo "prev"  ;;
        $'\x1b[C' | l | L) echo "next"  ;;
        r | R)              echo "reload";;
        q | Q | $'\x03')   echo "quit"  ;;
        *)                  echo ""      ;;
    esac
}

# ── Main loop ────────────────────────────────────────────────────────────────

cleanup() {
    stop_watcher
    show_cursor
    # Restore normal terminal state
    stty sane 2>/dev/null || true
    printf '\n'
    log "Exited."
}
trap cleanup EXIT INT TERM

main() {
    # Create watch dir if it doesn't exist
    if [[ ! -d "$WATCH_DIR" ]]; then
        warn "Directory '$WATCH_DIR' does not exist — creating it and waiting for files."
        mkdir -p "$WATCH_DIR"
    fi

    # Initial file scan
    refresh_file_list || true

    # Start background watcher
    start_watcher

    # Open the pipe for reading (non-blocking via background fd)
    exec 4<"$WATCH_PIPE"

    # Switch to raw keyboard mode
    hide_cursor
    stty -echo -icanon min 0 time 0 2>/dev/null || true

    # Initial draw
    draw_frame

    # Main event loop
    while true; do
        # Check for new files via the watch pipe (non-blocking)
        local pipe_byte=""
        IFS= read -r -u 4 -n1 -t 0 pipe_byte 2>/dev/null || true
        if [[ -n "$pipe_byte" ]]; then
            if refresh_file_list; then
                draw_frame
            fi
        fi

        # Handle keyboard input
        local action
        action=$(read_key)
        case "$action" in
            prev)
                if (( ${#FILES[@]} > 0 )); then
                    CURRENT_INDEX=$(( (CURRENT_INDEX - 1 + ${#FILES[@]}) % ${#FILES[@]} ))
                    draw_frame
                fi
                ;;
            next)
                if (( ${#FILES[@]} > 0 )); then
                    CURRENT_INDEX=$(( (CURRENT_INDEX + 1) % ${#FILES[@]} ))
                    draw_frame
                fi
                ;;
            reload)
                refresh_file_list || true
                draw_frame
                ;;
            quit)
                exit 0
                ;;
        esac
    done
}

main "$@"
