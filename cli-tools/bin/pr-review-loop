#!/usr/bin/env bash
# PR Review Loop
# TAGS: git, pr
# AUDIENCE: agent
#
# Automates the "push, request re-review, wait for results" cycle after
# fixing PR review comments. Companion to pr-create.
#
# Usage: pr-review-loop [PR_NUMBER] [OPTIONS]
#
# Examples:
#   pr-review-loop                    # Auto-detect PR from current branch
#   pr-review-loop 42                 # Specific PR number
#   pr-review-loop --message "Fixed auth bug and added tests"
#   pr-review-loop --no-push          # Skip git push (already pushed)
#   pr-review-loop --read             # Just poll for existing review results
#   pr-review-loop --timeout 10       # Wait max 10 minutes
#
# The tool will:
#   1. Push current branch to remote (unless --no-push)
#   2. Post a PR comment requesting re-review
#   3. Poll for new Greptile review comments
#   4. Output new review comments and confidence score

set -euo pipefail

POLL_INTERVAL=30        # seconds between checks
MAX_WAIT_TIME=900       # 15 minutes default
GREPTILE_BOT="greptile-apps[bot]"
GREPTILE_USER="greptile-apps"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() { echo -e "${BLUE}[pr-review-loop]${NC} $1"; }
warn() { echo -e "${YELLOW}[pr-review-loop]${NC} $1"; }
error() { echo -e "${RED}[pr-review-loop]${NC} $1" >&2; }
success() { echo -e "${GREEN}[pr-review-loop]${NC} $1"; }

# Show help
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
PR Review Loop

Automates the "push, request re-review, wait for results" cycle after
fixing PR review comments.

Usage: pr-review-loop [PR_NUMBER] [OPTIONS]

Arguments:
  PR_NUMBER           PR number (optional, auto-detected from current branch)

Options:
  --message MSG       Description of fixes applied (included in PR comment)
  --no-push           Skip git push step (if already pushed)
  --read              Read-only: skip push and comment, just poll for results
  --timeout MINS      Max wait time in minutes (default: 15)
  -h, --help          Show this help

Examples:
  pr-review-loop
  pr-review-loop 42
  pr-review-loop --message "Fixed auth bug and added tests"
  pr-review-loop --no-push --timeout 10
  pr-review-loop --read              # Just wait for existing review

Workflow:
  1. Push current branch to remote (unless --no-push)
  2. Post PR comment requesting re-review from @greptileai
  3. Poll for new Greptile review comments (every 30s)
  4. Output new comments and confidence score
  5. Exit 0 if score >= 4, exit 1 otherwise
EOF
    exit 0
fi

# Parse arguments
PR_NUMBER=""
MESSAGE=""
NO_PUSH=false
READ_ONLY=false
TIMEOUT_MINS=15

while [[ $# -gt 0 ]]; do
    case "$1" in
        --message)
            MESSAGE="$2"
            shift 2
            ;;
        --no-push)
            NO_PUSH=true
            shift
            ;;
        --read)
            READ_ONLY=true
            NO_PUSH=true
            shift
            ;;
        --timeout)
            TIMEOUT_MINS="$2"
            MAX_WAIT_TIME=$((TIMEOUT_MINS * 60))
            shift 2
            ;;
        -h|--help)
            # Already handled above
            shift
            ;;
        *)
            # Assume it's the PR number
            if [[ -z "$PR_NUMBER" ]]; then
                PR_NUMBER="$1"
            else
                error "Unknown argument: $1"
                exit 1
            fi
            shift
            ;;
    esac
done

# Verify we're in a git repo
if ! git rev-parse --show-toplevel &>/dev/null; then
    error "Must be run from within a git repository"
    exit 1
fi

# Get repo info
REPO=$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null) || {
    error "Could not determine repository. Make sure you're in a GitHub repo."
    exit 1
}

# Auto-detect PR number if not provided
if [[ -z "$PR_NUMBER" ]]; then
    log "Detecting PR from current branch..."
    PR_NUMBER=$(gh pr view --json number -q '.number' 2>/dev/null) || {
        error "Could not auto-detect PR number. Please specify PR number as argument."
        exit 1
    }
    success "Detected PR #$PR_NUMBER"
fi

# Step 1: Push to remote (unless --no-push)
if [[ "$NO_PUSH" == "false" ]]; then
    log "ðŸ”„ Pushing to origin..."
    CURRENT_BRANCH=$(git branch --show-current)
    git push origin "$CURRENT_BRANCH" || {
        error "Failed to push to origin"
        exit 1
    }
    success "Pushed to origin"
else
    log "Skipping push (--no-push specified)"
fi

# Get baseline comment counts and timestamps before posting
BASELINE_REVIEW_COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null | \
    jq --arg bot "$GREPTILE_BOT" '[.[] | select(.user.login == $bot)] | length')
BASELINE_ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
    jq --arg user "$GREPTILE_USER" '[.[] | select(.user.login == $user)] | length')

# Get the updated_at timestamp of the latest Greptile overview comment (if any)
BASELINE_OVERVIEW_TIMESTAMP=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
    jq --arg user "$GREPTILE_USER" -r '[.[] | select(.user.login == $user)] | sort_by(.updated_at) | .[-1].updated_at // ""')

# Step 2: Post re-review request comment (skip in --read mode)
if [[ "$READ_ONLY" == "false" ]]; then
    log "ðŸ“ Posting re-review request on PR #$PR_NUMBER..."

    # Build comment body
    COMMENT_BODY="## Fixes Applied"
    if [[ -n "$MESSAGE" ]]; then
        COMMENT_BODY="${COMMENT_BODY}\n\n${MESSAGE}"
    else
        COMMENT_BODY="${COMMENT_BODY}\n\nAddressed review feedback."
    fi
    COMMENT_BODY="${COMMENT_BODY}\n\n@greptileai please re-review"

    gh pr comment "$PR_NUMBER" --body "$(echo -e "$COMMENT_BODY")" || {
        error "Failed to post PR comment"
        exit 1
    }
    success "Posted re-review request"
else
    log "ðŸ‘€ Read-only mode: polling for existing review on PR #$PR_NUMBER..."
fi

# Step 3: Poll for new review comments
log "â³ Waiting for Greptile re-review (timeout: ${TIMEOUT_MINS}m)..."

START_TIME=$(date +%s)
NEW_INLINE_COUNT=0
NEW_OVERVIEW_COUNT=0
FOUND_OVERVIEW=false
OVERVIEW_UPDATED=false

while true; do
    ELAPSED=$(($(date +%s) - START_TIME))

    if [[ $ELAPSED -ge $MAX_WAIT_TIME ]]; then
        warn "Timeout reached (${TIMEOUT_MINS} minutes)."
        break
    fi

    # Fetch current comments
    CURRENT_REVIEW_COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null | \
        jq --arg bot "$GREPTILE_BOT" '[.[] | select(.user.login == $bot)] | length')
    CURRENT_ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
        jq --arg user "$GREPTILE_USER" '[.[] | select(.user.login == $user)] | length')

    NEW_INLINE_COUNT=$((CURRENT_REVIEW_COMMENTS - BASELINE_REVIEW_COMMENTS))
    NEW_OVERVIEW_COUNT=$((CURRENT_ISSUE_COMMENTS - BASELINE_ISSUE_COMMENTS))

    # Check for new overview comment OR updated existing overview comment
    CURRENT_OVERVIEW_TIMESTAMP=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
        jq --arg user "$GREPTILE_USER" -r '[.[] | select(.user.login == $user)] | sort_by(.updated_at) | .[-1].updated_at // ""')

    # Check if we have a new overview comment (the summary with Confidence Score)
    if [[ $NEW_OVERVIEW_COUNT -gt 0 ]]; then
        # Verify it actually has a confidence score
        LATEST_ISSUE_COMMENT=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
            jq --arg user "$GREPTILE_USER" -r '.[] | select(.user.login == $user) | .body' | tail -1)

        if echo "$LATEST_ISSUE_COMMENT" | grep -q "Confidence Score:"; then
            FOUND_OVERVIEW=true
            log "Found new overview comment with confidence score!"
            break
        fi
    # Check if existing overview comment was updated
    elif [[ -n "$BASELINE_OVERVIEW_TIMESTAMP" ]] && [[ -n "$CURRENT_OVERVIEW_TIMESTAMP" ]] && \
         [[ "$CURRENT_OVERVIEW_TIMESTAMP" != "$BASELINE_OVERVIEW_TIMESTAMP" ]]; then
        # Verify the updated comment has a confidence score
        LATEST_ISSUE_COMMENT=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null | \
            jq --arg user "$GREPTILE_USER" -r '[.[] | select(.user.login == $user)] | sort_by(.updated_at) | .[-1].body')

        if echo "$LATEST_ISSUE_COMMENT" | grep -q "Confidence Score:"; then
            FOUND_OVERVIEW=true
            OVERVIEW_UPDATED=true
            log "Existing overview comment was updated with new confidence score!"
            break
        fi
    fi

    ELAPSED_SECS=$ELAPSED
    STATUS=""
    if [[ "$OVERVIEW_UPDATED" == "true" ]]; then
        STATUS=" (updated)"
    fi
    printf "\r  Polling... (%d new inline, %d new overview%s) [%ds]   " \
        "$NEW_INLINE_COUNT" "$NEW_OVERVIEW_COUNT" "$STATUS" "$ELAPSED_SECS"
    sleep "$POLL_INTERVAL"
done

echo "" # New line after progress

# Step 4: Fetch and output the results
if [[ "$FOUND_OVERVIEW" == "false" ]] && [[ $NEW_INLINE_COUNT -eq 0 ]] && [[ $NEW_OVERVIEW_COUNT -eq 0 ]]; then
    warn "No new review comments found within timeout period."
    echo ""
    echo "Possible reasons:"
    echo "  - Greptile is still processing"
    echo "  - No new issues found"
    echo "  - Greptile not configured for this repo"
    echo ""
    echo "Check manually: https://github.com/${REPO}/pull/${PR_NUMBER}"
    exit 1
fi

log "Fetching review results..."

# Fetch all comments
ALL_REVIEW_COMMENTS=$(gh api "repos/${REPO}/pulls/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")
ALL_ISSUE_COMMENTS=$(gh api "repos/${REPO}/issues/${PR_NUMBER}/comments" 2>/dev/null || echo "[]")

# Get new inline comments (after baseline)
NEW_INLINE_COMMENTS=$(echo "$ALL_REVIEW_COMMENTS" | jq --arg bot "$GREPTILE_BOT" \
    --argjson baseline "$BASELINE_REVIEW_COMMENTS" '
    [.[] | select(.user.login == $bot)] |
    if length > ($baseline | tonumber) then .[$baseline:] else [] end
')

# Get new overview comments (after baseline) OR the updated one
if [[ "$OVERVIEW_UPDATED" == "true" ]]; then
    # If overview was updated (not new), get the latest one
    NEW_OVERVIEW_COMMENTS=$(echo "$ALL_ISSUE_COMMENTS" | jq --arg user "$GREPTILE_USER" \
        '[.[] | select(.user.login == $user)] | sort_by(.updated_at) | [.[-1]]')
else
    # Otherwise get new comments after baseline
    NEW_OVERVIEW_COMMENTS=$(echo "$ALL_ISSUE_COMMENTS" | jq --arg user "$GREPTILE_USER" \
        --argjson baseline "$BASELINE_ISSUE_COMMENTS" '
        [.[] | select(.user.login == $user)] |
        if length > ($baseline | tonumber) then .[$baseline:] else [] end
    ')
fi

# Extract confidence score from overview
CONFIDENCE_SCORE=""
CONFIDENCE_STATUS=""
if [[ $NEW_OVERVIEW_COUNT -gt 0 ]] || [[ "$OVERVIEW_UPDATED" == "true" ]]; then
    OVERVIEW_BODY=$(echo "$NEW_OVERVIEW_COMMENTS" | jq -r '.[0].body // ""')

    if [[ -n "$OVERVIEW_BODY" ]]; then
        # Try to extract confidence score (format: "Confidence Score: 4/5" or similar)
        if SCORE=$(echo "$OVERVIEW_BODY" | grep -oE 'Confidence Score: ([0-9])/5' | head -1); then
            CONFIDENCE_SCORE=$(echo "$SCORE" | grep -oE '[0-9]' | head -1)

            if [[ $CONFIDENCE_SCORE -ge 4 ]]; then
                CONFIDENCE_STATUS="âœ…"
            else
                CONFIDENCE_STATUS="âŒ"
            fi
        fi
    fi
fi

# Output formatted results
echo ""
echo "=============================================="
echo "PR #${PR_NUMBER} Re-Review Results"
echo "=============================================="
echo ""

if [[ -n "$CONFIDENCE_SCORE" ]]; then
    echo "Confidence Score: ${CONFIDENCE_SCORE}/5 ${CONFIDENCE_STATUS}"
    echo ""
fi

if [[ $NEW_INLINE_COUNT -gt 0 ]]; then
    echo "### New Inline Comments (${NEW_INLINE_COUNT}):"
    echo ""

    echo "$NEW_INLINE_COMMENTS" | jq -r '
        .[] |
        "### \(.user.login) - \(.path):\(.line // .original_line // "N/A")\n\(.body)\n"
    '
fi

if [[ $NEW_OVERVIEW_COUNT -gt 0 ]] || [[ "$OVERVIEW_UPDATED" == "true" ]]; then
    OVERVIEW_LABEL="### Overview:"
    if [[ "$OVERVIEW_UPDATED" == "true" ]]; then
        OVERVIEW_LABEL="### Overview (Updated):"
    fi
    echo "$OVERVIEW_LABEL"
    echo ""
    echo "$NEW_OVERVIEW_COMMENTS" | jq -r '.[] | .body'
    echo ""
fi

echo "=============================================="
echo "PR URL: https://github.com/${REPO}/pull/${PR_NUMBER}"
echo "=============================================="
echo ""

# Exit based on confidence score
if [[ -n "$CONFIDENCE_SCORE" ]]; then
    if [[ $CONFIDENCE_SCORE -ge 4 ]]; then
        success "Confidence score >= 4, review passed!"
        exit 0
    else
        warn "Confidence score < 4, further fixes needed."
        exit 1
    fi
else
    warn "Could not determine confidence score."
    exit 1
fi
