#!/usr/bin/env python3
# browser-console - Browser Console Capture Tool
# TAGS: system
# AUDIENCE: human, agent
"""
Browser Console Capture Tool

Captures console.log/warn/error output from a webpage using Playwright.

Usage:
    browser-console <url> [--wait <seconds>] [--timeout <seconds>]

Examples:
    browser-console http://localhost:3000
    browser-console http://localhost:3000 --wait 5
    browser-console https://dev.askcivic.com --timeout 30
"""

import argparse
import asyncio
import json
import sys
from pathlib import Path

# Add the project venv to path for playwright
VENV_SITE_PACKAGES = Path.home() / "ProcAgentDir/ProcurementAgentAI/.venv/lib/python3.12/site-packages"
if VENV_SITE_PACKAGES.exists():
    sys.path.insert(0, str(VENV_SITE_PACKAGES))

try:
    from playwright.async_api import async_playwright
except ImportError:
    print("Error: playwright not installed. Run: pip install playwright && playwright install chromium", file=sys.stderr)
    sys.exit(1)


async def capture_console(url: str, wait_seconds: float = 3, timeout_seconds: float = 30) -> dict:
    """Capture browser console output from a URL."""
    console_messages = []
    page_errors = []

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=True)
        context = await browser.new_context()
        page = await context.new_page()

        # Capture console messages
        def handle_console(msg):
            console_messages.append({
                "type": msg.type,
                "text": msg.text,
                "location": f"{msg.location.get('url', '')}:{msg.location.get('lineNumber', '')}" if msg.location else ""
            })

        # Capture page errors
        def handle_error(error):
            page_errors.append(str(error))

        page.on("console", handle_console)
        page.on("pageerror", handle_error)

        try:
            # Navigate to the page
            await page.goto(url, timeout=timeout_seconds * 1000, wait_until="networkidle")

            # Wait for React/JS to hydrate
            await asyncio.sleep(wait_seconds)

        except Exception as e:
            page_errors.append(f"Navigation error: {e}")

        await browser.close()

    return {
        "url": url,
        "console": console_messages,
        "errors": page_errors
    }


def format_output(result: dict, output_format: str = "text") -> str:
    """Format the captured output."""
    if output_format == "json":
        return json.dumps(result, indent=2)

    lines = []

    # Console messages
    if result["console"]:
        for msg in result["console"]:
            type_prefix = {
                "log": "[log]",
                "info": "[info]",
                "warning": "[warn]",
                "error": "[error]",
                "debug": "[debug]"
            }.get(msg["type"], f"[{msg['type']}]")
            lines.append(f"{type_prefix} {msg['text']}")

    # Page errors
    if result["errors"]:
        for err in result["errors"]:
            lines.append(f"[PAGE ERROR] {err}")

    if not lines:
        lines.append("(no console output)")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Capture browser console output from a URL")
    parser.add_argument("url", help="URL to capture console from")
    parser.add_argument("--wait", type=float, default=3, help="Seconds to wait after page load (default: 3)")
    parser.add_argument("--timeout", type=float, default=30, help="Page load timeout in seconds (default: 30)")
    parser.add_argument("--format", choices=["text", "json"], default="text", help="Output format (default: text)")

    args = parser.parse_args()

    result = asyncio.run(capture_console(args.url, args.wait, args.timeout))
    print(format_output(result, args.format))

    # Exit with error code if there were errors
    has_errors = any(msg["type"] == "error" for msg in result["console"]) or result["errors"]
    sys.exit(1 if has_errors else 0)


if __name__ == "__main__":
    main()
