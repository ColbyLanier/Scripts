#!/usr/bin/env bash
# Worktree Setup - create git worktrees with environment files and dependencies
# TAGS: git, worktree
# AUDIENCE: human, agent
#
# Usage: worktree-setup <branch-name> [options]
#
# Creates a new worktree as a sibling directory, copies necessary .gitignore'd
# files (.env, etc.), and runs package sync.
#
# Examples:
#   worktree-setup feature-auth          # Create worktree for new branch
#   worktree-setup fix-bug --existing    # Use existing branch
#   worktree-setup my-feature --dry-run  # Preview what would happen

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Defaults
DRY_RUN=false
USE_EXISTING_BRANCH=false
SKIP_SYNC=false
NO_TRANSPLANT=false

usage() {
    cat << 'EOF'
Worktree Setup - create git worktrees with environment files and dependencies

Usage: worktree-setup <branch-name> [options]

Arguments:
  branch-name         Name for the new branch and worktree directory

Options:
  -e, --existing        Use an existing branch instead of creating new one
  -n, --dry-run         Show what would happen without making changes
  -s, --skip-sync       Skip running uv sync / npm install
  --no-transplant       Skip session transplant (for subagents or non-interactive use)
  -h, --help            Show this help message

Description:
  Creates a new git worktree as a sibling directory (../repo-branch-name),
  copies necessary .gitignore'd files, and syncs dependencies.

Files copied:
  - .env (root environment file)
  - widget/.env.* (widget environment configs)
  - deploy/*.json (service account credentials)

Examples:
  worktree-setup feature-auth          # Create worktree with new branch
  worktree-setup fix-bug --existing    # Worktree for existing branch
  worktree-setup my-feature --dry-run  # Preview without changes
EOF
    exit 0
}

log_info() {
    echo -e "${BLUE}→${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}!${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

# Parse arguments
BRANCH_NAME=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -e|--existing)
            USE_EXISTING_BRANCH=true
            shift
            ;;
        -s|--skip-sync)
            SKIP_SYNC=true
            shift
            ;;
        --no-transplant)
            NO_TRANSPLANT=true
            shift
            ;;
        -*)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
        *)
            if [[ -z "$BRANCH_NAME" ]]; then
                BRANCH_NAME="$1"
            else
                log_error "Too many arguments"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate arguments
if [[ -z "$BRANCH_NAME" ]]; then
    log_error "Branch name required"
    echo "Usage: worktree-setup <branch-name> [options]"
    echo "Use --help for more information"
    exit 1
fi

# Check we're in a git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not in a git repository"
    exit 1
fi

# Get repo info
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")
PARENT_DIR=$(dirname "$REPO_ROOT")
WORKTREE_DIR="$PARENT_DIR/${REPO_NAME}-${BRANCH_NAME}"

# Check if worktree already exists
if [[ -d "$WORKTREE_DIR" ]]; then
    log_error "Directory already exists: $WORKTREE_DIR"
    exit 1
fi

# Check if branch exists (if --existing not specified)
BRANCH_EXISTS=$(git branch --list "$BRANCH_NAME" | wc -l)
REMOTE_EXISTS=$(git branch -r --list "origin/$BRANCH_NAME" | wc -l)

if [[ "$USE_EXISTING_BRANCH" == "false" ]]; then
    if [[ $BRANCH_EXISTS -gt 0 ]] || [[ $REMOTE_EXISTS -gt 0 ]]; then
        log_error "Branch '$BRANCH_NAME' already exists. Use --existing to use it."
        exit 1
    fi
else
    if [[ $BRANCH_EXISTS -eq 0 ]] && [[ $REMOTE_EXISTS -eq 0 ]]; then
        log_error "Branch '$BRANCH_NAME' does not exist"
        exit 1
    fi
fi

# Identify files to copy
FILES_TO_COPY=()

# Root .env
if [[ -f "$REPO_ROOT/.env" ]]; then
    FILES_TO_COPY+=(".env")
fi

# widget/.env.* files (widget environment configs)
if [[ -d "$REPO_ROOT/widget" ]]; then
    for envfile in "$REPO_ROOT"/widget/.env.*; do
        if [[ -f "$envfile" ]]; then
            FILES_TO_COPY+=("widget/$(basename "$envfile")")
        fi
    done
fi

# deploy/*.json files (service account credentials)
if [[ -d "$REPO_ROOT/deploy" ]]; then
    for jsonfile in "$REPO_ROOT"/deploy/*.json; do
        if [[ -f "$jsonfile" ]]; then
            FILES_TO_COPY+=("deploy/$(basename "$jsonfile")")
        fi
    done
fi

# Show plan
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo " Worktree Setup Plan"
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "  Repository:    $REPO_NAME"
echo "  Branch:        $BRANCH_NAME $(if [[ "$USE_EXISTING_BRANCH" == "true" ]]; then echo "(existing)"; else echo "(new)"; fi)"
echo "  Worktree:      $WORKTREE_DIR"
echo ""

if [[ ${#FILES_TO_COPY[@]} -gt 0 ]]; then
    echo "  Files to copy:"
    for file in "${FILES_TO_COPY[@]}"; do
        echo "    - $file"
    done
else
    echo "  Files to copy: (none found)"
fi
echo ""

# Detect package manager
PKG_MANAGER=""
if [[ -f "$REPO_ROOT/pyproject.toml" ]]; then
    if grep -q "uv" "$REPO_ROOT/pyproject.toml" 2>/dev/null || [[ -f "$REPO_ROOT/uv.lock" ]]; then
        PKG_MANAGER="uv"
    elif [[ -f "$REPO_ROOT/poetry.lock" ]]; then
        PKG_MANAGER="poetry"
    else
        PKG_MANAGER="pip"
    fi
elif [[ -f "$REPO_ROOT/requirements.txt" ]]; then
    PKG_MANAGER="pip"
fi

# Check for npm dependencies (root and subdirectories)
HAS_NPM=false
if [[ -f "$REPO_ROOT/package.json" ]]; then
    HAS_NPM=true
fi
for dir in widget frontend; do
    if [[ -d "$REPO_ROOT/$dir" ]] && [[ -f "$REPO_ROOT/$dir/package.json" ]]; then
        HAS_NPM=true
        break
    fi
done
if [[ "$HAS_NPM" == "true" ]]; then
    if [[ -n "$PKG_MANAGER" ]]; then
        PKG_MANAGER="$PKG_MANAGER + npm"
    else
        PKG_MANAGER="npm"
    fi
fi

if [[ -n "$PKG_MANAGER" ]] && [[ "$SKIP_SYNC" == "false" ]]; then
    echo "  Package sync:  $PKG_MANAGER"
else
    echo "  Package sync:  (skipped)"
fi
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo ""

if [[ "$DRY_RUN" == "true" ]]; then
    log_warn "Dry run - no changes made"
    exit 0
fi

# Execute
log_info "Creating worktree..."
if [[ "$USE_EXISTING_BRANCH" == "true" ]]; then
    git worktree add "$WORKTREE_DIR" "$BRANCH_NAME"
else
    git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR"
fi
log_success "Worktree created at $WORKTREE_DIR"

# Copy files
if [[ ${#FILES_TO_COPY[@]} -gt 0 ]]; then
    log_info "Copying environment files..."
    for file in "${FILES_TO_COPY[@]}"; do
        src="$REPO_ROOT/$file"
        dst="$WORKTREE_DIR/$file"

        # Ensure destination directory exists
        mkdir -p "$(dirname "$dst")"

        if [[ -f "$src" ]]; then
            cp "$src" "$dst"
            log_success "Copied $file"
        else
            log_warn "Skipped $file (not found)"
        fi
    done
fi

# Create config directory (required by Dockerfile but git-ignored)
log_info "Creating config directory..."
mkdir -p "$WORKTREE_DIR/config"
log_success "Created config/ directory"

# Sync dependencies
if [[ -n "$PKG_MANAGER" ]] && [[ "$SKIP_SYNC" == "false" ]]; then
    log_info "Syncing dependencies..."
    cd "$WORKTREE_DIR"

    if [[ "$PKG_MANAGER" == *"uv"* ]]; then
        uv sync
        log_success "Python dependencies synced (uv)"
    elif [[ "$PKG_MANAGER" == *"poetry"* ]]; then
        poetry install
        log_success "Python dependencies synced (poetry)"
    elif [[ "$PKG_MANAGER" == *"pip"* ]]; then
        pip install -r requirements.txt
        log_success "Python dependencies synced (pip)"
    fi

    if [[ "$PKG_MANAGER" == *"npm"* ]]; then
        # Root package.json (e.g., puppeteer, dotenv for E2E tests)
        if [[ -f "$WORKTREE_DIR/package.json" ]]; then
            cd "$WORKTREE_DIR"
            npm install
            log_success "Node dependencies synced (root)"
        fi

        # Subdirectory package.json (widget, frontend)
        for dir in widget frontend; do
            if [[ -d "$WORKTREE_DIR/$dir" ]] && [[ -f "$WORKTREE_DIR/$dir/package.json" ]]; then
                cd "$WORKTREE_DIR/$dir"
                npm install
                log_success "Node dependencies synced ($dir)"
            fi
        done
    fi
fi

echo ""

# Register quick cd alias (branch name → worktree dir)
CD_QUICK_ALIASES_FILE="$HOME/.cd_quick_aliases"
if grep -q "^${BRANCH_NAME}=" "$CD_QUICK_ALIASES_FILE" 2>/dev/null; then
    sed -i "s|^${BRANCH_NAME}=.*|${BRANCH_NAME}=${WORKTREE_DIR}|" "$CD_QUICK_ALIASES_FILE"
else
    echo "${BRANCH_NAME}=${WORKTREE_DIR}" >> "$CD_QUICK_ALIASES_FILE"
fi
log_success "CD alias registered: cd $BRANCH_NAME → $WORKTREE_DIR"

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo -e " ${GREEN}Worktree ready!${NC}"
echo "═══════════════════════════════════════════════════════════════"
echo ""

# ═══════════════════════════════════════════════════════════════
# Session Transplant: kill Claude and restart in the worktree
# ═══════════════════════════════════════════════════════════════

# Encode a path the way Claude Code does (/ and . become -)
encode_claude_path() {
    echo "$1" | tr '/.' '-'
}

# Walk /proc to find the Claude ancestor process
find_claude_pid() {
    local current="$PPID"
    for _ in 1 2 3 4 5 6 7 8; do
        [[ -z "$current" || "$current" == "1" || "$current" == "0" ]] && break
        local comm
        comm=$(cat "/proc/$current/comm" 2>/dev/null) || break
        if [[ "$comm" == "claude" ]]; then
            echo "$current"
            return 0
        fi
        current=$(awk '{print $4}' "/proc/$current/stat" 2>/dev/null) || break
    done
    return 1
}

# Find the tmux pane containing a given PID (walks ancestry)
find_tmux_pane() {
    local target_pid=$1
    tmux list-panes -a -F '#{pane_id} #{pane_pid}' 2>/dev/null | while read -r pane_id pane_pid; do
        local check_pid=$target_pid
        while [[ -n "$check_pid" && "$check_pid" != "1" && "$check_pid" != "0" ]]; do
            if [[ "$check_pid" == "$pane_pid" ]]; then
                echo "$pane_id"
                return 0
            fi
            check_pid=$(awk '{print $4}' "/proc/$check_pid/stat" 2>/dev/null) || break
        done
    done | head -1
}

transplant_session() {
    # Check preconditions
    if [[ "$NO_TRANSPLANT" == "true" ]]; then
        return 1
    fi
    # Claude strips $TMUX from tool env, so detect via tmux command
    if ! tmux display-message -p '#{session_name}' &>/dev/null; then
        log_info "Not in tmux — transplant skipped"
        echo "  For auto-transplant, run Claude from tmux (or use the claude wrapper)"
        echo ""
        echo "  Manual: cd $WORKTREE_DIR && claude --continue --fork-session"
        return 1
    fi

    # Find parent Claude process
    local claude_pid
    claude_pid=$(find_claude_pid) || {
        log_warn "Claude PID not found — transplant skipped"
        echo "  cd $WORKTREE_DIR"
        return 1
    }

    # Find session ID from cache (written by SessionStart hook)
    local session_id=""
    if [[ -f "${HOME}/.claude/session-pids/${claude_pid}" ]]; then
        session_id=$(cat "${HOME}/.claude/session-pids/${claude_pid}" 2>/dev/null)
    fi

    # Fallback: most recent JSONL in source project dir
    local source_encoded
    source_encoded=$(encode_claude_path "$REPO_ROOT")
    local source_project_dir="${HOME}/.claude/projects/${source_encoded}"
    if [[ -z "$session_id" && -d "$source_project_dir" ]]; then
        local latest_jsonl
        latest_jsonl=$(ls -t "$source_project_dir"/*.jsonl 2>/dev/null | head -1)
        if [[ -n "$latest_jsonl" ]]; then
            session_id=$(basename "$latest_jsonl" .jsonl)
            log_warn "Session ID cache miss — using most recent JSONL: ${session_id:0:8}..."
        fi
    fi

    if [[ -z "$session_id" ]]; then
        log_warn "No session ID found — transplant skipped"
        echo "  cd $WORKTREE_DIR"
        return 1
    fi

    # Copy JSONL to target project directory
    local target_encoded
    target_encoded=$(encode_claude_path "$WORKTREE_DIR")
    local target_project_dir="${HOME}/.claude/projects/${target_encoded}"
    local source_jsonl="${source_project_dir}/${session_id}.jsonl"

    if [[ ! -f "$source_jsonl" ]]; then
        log_warn "Session JSONL not found: $source_jsonl"
        echo "  cd $WORKTREE_DIR"
        return 1
    fi

    mkdir -p "$target_project_dir"
    cp "$source_jsonl" "$target_project_dir/"
    log_success "Session transcript copied to worktree project dir"

    # Find tmux pane (Claude strips $TMUX_PANE, always use PID-based lookup)
    local pane_target
    pane_target=$(find_tmux_pane "$claude_pid")
    if [[ -z "$pane_target" ]]; then
        log_warn "Could not identify tmux pane — transplant skipped"
        echo "  cd $WORKTREE_DIR && claude --resume $session_id --fork-session"
        return 1
    fi

    # Capture old instance name for transfer to new session
    local old_tab_name=""
    local old_instance_id="$session_id"
    if command -v curl &>/dev/null && command -v jq &>/dev/null; then
        old_tab_name=$(curl -s "http://localhost:7777/api/instances" 2>/dev/null | \
            jq -r --arg id "$old_instance_id" \
            '.[] | select(.id == $id) | .tab_name // empty' 2>/dev/null || true)
    fi

    log_info "Transplanting session to worktree..."

    # Spawn a detached restart daemon that:
    # 1. Waits for Claude to exit
    # 2. Sends the restart command to the tmux pane's shell
    (
        exec 0</dev/null 1>/dev/null 2>/dev/null

        # Wait for Claude to fully exit
        local wait_count=0
        while kill -0 "$claude_pid" 2>/dev/null; do
            sleep 0.5
            wait_count=$((wait_count + 1))
            if [[ $wait_count -ge 20 ]]; then
                # 10 seconds max wait — give up
                break
            fi
        done
        sleep 0.5  # Grace period for shell to regain control

        # Send restart command to the tmux pane
        tmux send-keys -t "$pane_target" \
            "cd '$WORKTREE_DIR' && /home/token/.local/bin/claude --dangerously-skip-permissions --resume '$session_id' --fork-session" \
            Enter

        # Transfer instance name and clean up old instance
        if [[ -n "$old_tab_name" && -n "$old_instance_id" ]]; then
            # Wait for new instance to register (up to 30s)
            local new_id=""
            for attempt in $(seq 1 30); do
                sleep 1
                new_id=$(curl -s "http://localhost:7777/api/instances" 2>/dev/null | \
                    jq -r --arg dir "$WORKTREE_DIR" \
                    '.[] | select(.working_dir == $dir and (.status == "processing" or .status == "idle")) | .id' 2>/dev/null | head -1 || true)
                [[ -n "$new_id" ]] && break
            done

            if [[ -n "$new_id" ]]; then
                # Transfer tab_name to new instance
                curl -s -X PATCH "http://localhost:7777/api/instances/${new_id}/rename" \
                    -H "Content-Type: application/json" \
                    -d "{\"tab_name\": \"${old_tab_name}\"}" >/dev/null 2>&1 || true
            fi

            # Delete old instance (belt + suspenders — SessionEnd may not fire on SIGKILL)
            curl -s -X DELETE "http://localhost:7777/api/instances/${old_instance_id}" >/dev/null 2>&1 || true
        fi
    ) &
    disown

    # Ignore signals during shutdown — we must complete the kill
    trap '' INT HUP TERM

    # Kill Claude (SIGINT for graceful shutdown)
    kill -INT "$claude_pid" 2>/dev/null || true
    sleep 1.5

    # Double-SIGINT if still alive (matches token-api pattern)
    if kill -0 "$claude_pid" 2>/dev/null; then
        kill -INT "$claude_pid" 2>/dev/null || true
        sleep 2
    fi

    # Force kill as last resort
    if kill -0 "$claude_pid" 2>/dev/null; then
        kill -KILL "$claude_pid" 2>/dev/null || true
    fi

    exit 0
}

# Attempt transplant; if it fails or is skipped, show manual command
transplant_session || echo "  cd $WORKTREE_DIR"
echo ""
