#!/usr/bin/env bash
# Worktree Setup - create git worktrees with environment files and dependencies
#
# Usage: worktree-setup <branch-name> [options]
#
# Creates a new worktree as a sibling directory, copies necessary .gitignore'd
# files (.env, etc.), and runs package sync.
#
# Examples:
#   worktree-setup feature-auth          # Create worktree for new branch
#   worktree-setup fix-bug --existing    # Use existing branch
#   worktree-setup my-feature --dry-run  # Preview what would happen

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Defaults
DRY_RUN=false
USE_EXISTING_BRANCH=false
SKIP_SYNC=false

usage() {
    cat << 'EOF'
Worktree Setup - create git worktrees with environment files and dependencies

Usage: worktree-setup <branch-name> [options]

Arguments:
  branch-name         Name for the new branch and worktree directory

Options:
  -e, --existing      Use an existing branch instead of creating new one
  -n, --dry-run       Show what would happen without making changes
  -s, --skip-sync     Skip running uv sync / npm install
  -h, --help          Show this help message

Description:
  Creates a new git worktree as a sibling directory (../repo-branch-name),
  copies necessary .gitignore'd files, and syncs dependencies.

Files copied:
  - .env (root environment file)
  - widget/.env.* (widget environment configs)
  - deploy/*.json (service account credentials)

Examples:
  worktree-setup feature-auth          # Create worktree with new branch
  worktree-setup fix-bug --existing    # Worktree for existing branch
  worktree-setup my-feature --dry-run  # Preview without changes
EOF
    exit 0
}

log_info() {
    echo -e "${BLUE}→${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}!${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

# Parse arguments
BRANCH_NAME=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -e|--existing)
            USE_EXISTING_BRANCH=true
            shift
            ;;
        -s|--skip-sync)
            SKIP_SYNC=true
            shift
            ;;
        -*)
            log_error "Unknown option: $1"
            echo "Use --help for usage information"
            exit 1
            ;;
        *)
            if [[ -z "$BRANCH_NAME" ]]; then
                BRANCH_NAME="$1"
            else
                log_error "Too many arguments"
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate arguments
if [[ -z "$BRANCH_NAME" ]]; then
    log_error "Branch name required"
    echo "Usage: worktree-setup <branch-name> [options]"
    echo "Use --help for more information"
    exit 1
fi

# Check we're in a git repo
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    log_error "Not in a git repository"
    exit 1
fi

# Get repo info
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")
PARENT_DIR=$(dirname "$REPO_ROOT")
WORKTREE_DIR="$PARENT_DIR/${REPO_NAME}-${BRANCH_NAME}"

# Check if worktree already exists
if [[ -d "$WORKTREE_DIR" ]]; then
    log_error "Directory already exists: $WORKTREE_DIR"
    exit 1
fi

# Check if branch exists (if --existing not specified)
BRANCH_EXISTS=$(git branch --list "$BRANCH_NAME" | wc -l)
REMOTE_EXISTS=$(git branch -r --list "origin/$BRANCH_NAME" | wc -l)

if [[ "$USE_EXISTING_BRANCH" == "false" ]]; then
    if [[ $BRANCH_EXISTS -gt 0 ]] || [[ $REMOTE_EXISTS -gt 0 ]]; then
        log_error "Branch '$BRANCH_NAME' already exists. Use --existing to use it."
        exit 1
    fi
else
    if [[ $BRANCH_EXISTS -eq 0 ]] && [[ $REMOTE_EXISTS -eq 0 ]]; then
        log_error "Branch '$BRANCH_NAME' does not exist"
        exit 1
    fi
fi

# Identify files to copy
FILES_TO_COPY=()

# Root .env
if [[ -f "$REPO_ROOT/.env" ]]; then
    FILES_TO_COPY+=(".env")
fi

# widget/.env.* files (widget environment configs)
if [[ -d "$REPO_ROOT/widget" ]]; then
    for envfile in "$REPO_ROOT"/widget/.env.*; do
        if [[ -f "$envfile" ]]; then
            FILES_TO_COPY+=("widget/$(basename "$envfile")")
        fi
    done
fi

# deploy/*.json files (service account credentials)
if [[ -d "$REPO_ROOT/deploy" ]]; then
    for jsonfile in "$REPO_ROOT"/deploy/*.json; do
        if [[ -f "$jsonfile" ]]; then
            FILES_TO_COPY+=("deploy/$(basename "$jsonfile")")
        fi
    done
fi

# Show plan
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo " Worktree Setup Plan"
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "  Repository:    $REPO_NAME"
echo "  Branch:        $BRANCH_NAME $(if [[ "$USE_EXISTING_BRANCH" == "true" ]]; then echo "(existing)"; else echo "(new)"; fi)"
echo "  Worktree:      $WORKTREE_DIR"
echo ""

if [[ ${#FILES_TO_COPY[@]} -gt 0 ]]; then
    echo "  Files to copy:"
    for file in "${FILES_TO_COPY[@]}"; do
        echo "    - $file"
    done
else
    echo "  Files to copy: (none found)"
fi
echo ""

# Detect package manager
PKG_MANAGER=""
if [[ -f "$REPO_ROOT/pyproject.toml" ]]; then
    if grep -q "uv" "$REPO_ROOT/pyproject.toml" 2>/dev/null || [[ -f "$REPO_ROOT/uv.lock" ]]; then
        PKG_MANAGER="uv"
    elif [[ -f "$REPO_ROOT/poetry.lock" ]]; then
        PKG_MANAGER="poetry"
    else
        PKG_MANAGER="pip"
    fi
elif [[ -f "$REPO_ROOT/requirements.txt" ]]; then
    PKG_MANAGER="pip"
fi

# Check for widget or frontend with their own package.json
for dir in widget frontend; do
    if [[ -d "$REPO_ROOT/$dir" ]] && [[ -f "$REPO_ROOT/$dir/package.json" ]]; then
        if [[ -n "$PKG_MANAGER" ]]; then
            PKG_MANAGER="$PKG_MANAGER + npm"
        else
            PKG_MANAGER="npm"
        fi
        break  # Only add npm once
    fi
done

if [[ -n "$PKG_MANAGER" ]] && [[ "$SKIP_SYNC" == "false" ]]; then
    echo "  Package sync:  $PKG_MANAGER"
else
    echo "  Package sync:  (skipped)"
fi
echo ""
echo "═══════════════════════════════════════════════════════════════"
echo ""

if [[ "$DRY_RUN" == "true" ]]; then
    log_warn "Dry run - no changes made"
    exit 0
fi

# Execute
log_info "Creating worktree..."
if [[ "$USE_EXISTING_BRANCH" == "true" ]]; then
    git worktree add "$WORKTREE_DIR" "$BRANCH_NAME"
else
    git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR"
fi
log_success "Worktree created at $WORKTREE_DIR"

# Copy files
if [[ ${#FILES_TO_COPY[@]} -gt 0 ]]; then
    log_info "Copying environment files..."
    for file in "${FILES_TO_COPY[@]}"; do
        src="$REPO_ROOT/$file"
        dst="$WORKTREE_DIR/$file"

        # Ensure destination directory exists
        mkdir -p "$(dirname "$dst")"

        if [[ -f "$src" ]]; then
            cp "$src" "$dst"
            log_success "Copied $file"
        else
            log_warn "Skipped $file (not found)"
        fi
    done
fi

# Create config directory (required by Dockerfile but git-ignored)
log_info "Creating config directory..."
mkdir -p "$WORKTREE_DIR/config"
log_success "Created config/ directory"

# Sync dependencies
if [[ -n "$PKG_MANAGER" ]] && [[ "$SKIP_SYNC" == "false" ]]; then
    log_info "Syncing dependencies..."
    cd "$WORKTREE_DIR"

    if [[ "$PKG_MANAGER" == *"uv"* ]]; then
        uv sync
        log_success "Python dependencies synced (uv)"
    elif [[ "$PKG_MANAGER" == *"poetry"* ]]; then
        poetry install
        log_success "Python dependencies synced (poetry)"
    elif [[ "$PKG_MANAGER" == *"pip"* ]]; then
        pip install -r requirements.txt
        log_success "Python dependencies synced (pip)"
    fi

    if [[ "$PKG_MANAGER" == *"npm"* ]]; then
        # Check for widget or frontend directories
        for dir in widget frontend; do
            if [[ -d "$WORKTREE_DIR/$dir" ]] && [[ -f "$WORKTREE_DIR/$dir/package.json" ]]; then
                cd "$WORKTREE_DIR/$dir"
                npm install
                log_success "Node dependencies synced ($dir)"
            fi
        done
    fi
fi

echo ""

# Register quick cd alias (branch name → worktree dir)
CD_QUICK_ALIASES_FILE="$HOME/.cd_quick_aliases"
if grep -q "^${BRANCH_NAME}=" "$CD_QUICK_ALIASES_FILE" 2>/dev/null; then
    sed -i "s|^${BRANCH_NAME}=.*|${BRANCH_NAME}=${WORKTREE_DIR}|" "$CD_QUICK_ALIASES_FILE"
else
    echo "${BRANCH_NAME}=${WORKTREE_DIR}" >> "$CD_QUICK_ALIASES_FILE"
fi
log_success "CD alias registered: cd $BRANCH_NAME → $WORKTREE_DIR"

echo ""
echo "═══════════════════════════════════════════════════════════════"
echo -e " ${GREEN}Worktree ready!${NC}"
echo "═══════════════════════════════════════════════════════════════"
echo ""
echo "  cd $WORKTREE_DIR"
echo ""
