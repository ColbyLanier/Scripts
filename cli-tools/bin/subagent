#!/usr/bin/env bash
# subagent - Multi-backend sub-agent launcher
# TAGS: instance
# AUDIENCE: agent
#
# Backends: openclaw (default), codex, claude
# Modes: async (default), --blocking, --persona
#
# Usage: subagent [options] "prompt"
#   subagent "do something"                    # OpenClaw async
#   subagent --blocking "what time is it?"     # Wait for result
#   subagent --codex "explain this code"       # GPT backend
#   subagent --claude "fix the bug"            # Claude Code backend
#   subagent --persona                         # Interactive mode
#   subagent --agent ops "check status"        # Specific OpenClaw agent
#   subagent --session my-task "do step 1"     # Named session

set -euo pipefail

LOG_DIR="$HOME/.subagent/logs"
CLAUDE_BIN="$HOME/.local/bin/claude"

# --- Host mapping (reuses ssh-connect aliases) ---
host_to_ssh() {
    case "$1" in
        mac)   echo "mini" ;;
        wsl)   echo "wsl" ;;
        phone) echo "phone" ;;
        *)     echo "Error: unknown host '$1' (expected mac, wsl, phone)" >&2; exit 1 ;;
    esac
}

# --- Defaults ---
BACKEND="openclaw"
MODE="async"
AGENT="main"
SESSION_ID=""
REMOTE_HOST=""
REMOTE_DIR=""
PROMPT=""

# --- Help ---
usage() {
    cat << 'EOF'
subagent - Multi-backend sub-agent launcher

Usage: subagent [options] "prompt"

Backends:
  (default)       OpenClaw (MiniMax M2.5 via gateway)
  --codex         Codex / GPT backend
  --claude        Claude Code backend

Modes:
  (default)       Async: background the agent, log output
  --blocking      Synchronous: wait for result, print to stdout
  --persona       Interactive: exec into backend's TUI/REPL (no return)

Options:
  --agent <name>  OpenClaw agent name (default: main)
  --session <id>  OpenClaw session ID (default: isolated)
  -h, --help      Show this help

Remote:
  --host <target> Spawn agent on remote machine (mac, wsl, phone)
  --dir <path>    Working directory on remote (default: ~)

Examples:
  subagent "summarize today's tasks"
  subagent --blocking "what is 2+2?"
  subagent --codex "explain this error"
  subagent --claude --blocking "fix the auth bug"
  subagent --persona
  subagent --agent ops "check system health"
  subagent --session deploy-v2 "continue deployment"

Remote examples:
  subagent --host wsl --claude --blocking "fix the bug"
  subagent --host mac --claude "run tests in background"
  subagent --host wsl --persona
  subagent --host wsl --dir /home/token/project --claude "check status"
EOF
    exit 0
}

# --- Parse args ---
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            usage
            ;;
        --codex)
            BACKEND="codex"
            shift
            ;;
        --claude)
            BACKEND="claude"
            shift
            ;;
        --blocking)
            MODE="blocking"
            shift
            ;;
        --persona)
            MODE="persona"
            shift
            ;;
        --agent)
            AGENT="$2"
            shift 2
            ;;
        --session)
            SESSION_ID="$2"
            shift 2
            ;;
        --host)
            REMOTE_HOST="$2"
            shift 2
            ;;
        --dir)
            REMOTE_DIR="$2"
            shift 2
            ;;
        -*)
            echo "Unknown option: $1" >&2
            echo "Run 'subagent --help' for usage." >&2
            exit 1
            ;;
        *)
            PROMPT="$1"
            shift
            ;;
    esac
done

# --- Validate ---
if [[ "$MODE" != "persona" && -z "$PROMPT" ]]; then
    echo "Error: prompt is required for $MODE mode." >&2
    echo "Usage: subagent [options] \"prompt\"" >&2
    exit 1
fi

# --- Backend availability checks ---
check_codex() {
    if ! command -v codex &>/dev/null; then
        echo "Error: codex not found. Install it first." >&2
        exit 1
    fi
}

check_claude() {
    if [[ ! -x "$CLAUDE_BIN" ]]; then
        echo "Error: claude not found at $CLAUDE_BIN" >&2
        exit 1
    fi
}

check_openclaw() {
    if ! command -v openclaw &>/dev/null; then
        echo "Error: openclaw not found." >&2
        exit 1
    fi
}

# --- Job ID for async ---
make_job_id() {
    echo "${BACKEND}-$(date +%Y%m%d-%H%M%S)-$$"
}

# --- Async launcher ---
run_async() {
    mkdir -p "$LOG_DIR"
    local job_id
    job_id="$(make_job_id)"
    local logfile="$LOG_DIR/${job_id}.log"

    case "$BACKEND" in
        openclaw)
            check_openclaw
            local cmd=(openclaw agent --agent "$AGENT" --message "$PROMPT")
            [[ -n "$SESSION_ID" ]] && cmd+=(--session-id "$SESSION_ID")
            nohup "${cmd[@]}" > "$logfile" 2>&1 &
            ;;
        codex)
            check_codex
            nohup codex "$PROMPT" > "$logfile" 2>&1 &
            ;;
        claude)
            check_claude
            export TOKEN_API_SUBAGENT="subagent:claude"
            nohup "$CLAUDE_BIN" --dangerously-skip-permissions -p "$PROMPT" > "$logfile" 2>&1 &
            ;;
    esac

    local pid=$!
    local agent_info=""
    [[ "$BACKEND" == "openclaw" ]] && agent_info=" (agent: $AGENT)"

    echo "Job: $job_id"
    echo "Log: $logfile"
    echo "Backend: ${BACKEND}${agent_info}"
    echo "PID: $pid"
}

# --- Blocking runner ---
run_blocking() {
    case "$BACKEND" in
        openclaw)
            check_openclaw
            local cmd=(openclaw agent --agent "$AGENT" --message "$PROMPT")
            [[ -n "$SESSION_ID" ]] && cmd+=(--session-id "$SESSION_ID")
            "${cmd[@]}"
            ;;
        codex)
            check_codex
            codex "$PROMPT"
            ;;
        claude)
            check_claude
            export TOKEN_API_SUBAGENT="subagent:claude"
            "$CLAUDE_BIN" --dangerously-skip-permissions -p "$PROMPT"
            ;;
    esac
}

# --- Persona (exec, no return) ---
run_persona() {
    case "$BACKEND" in
        openclaw)
            check_openclaw
            exec openclaw tui
            ;;
        codex)
            check_codex
            exec codex
            ;;
        claude)
            check_claude
            exec "$CLAUDE_BIN"
            ;;
    esac
}

# --- Remote runner ---
run_remote() {
    local ssh_target
    ssh_target=$(host_to_ssh "$REMOTE_HOST")

    # Pre-flight connectivity check
    if ! ssh -o ConnectTimeout=5 -o BatchMode=yes "$ssh_target" true 2>/dev/null; then
        echo "Error: cannot reach host '$REMOTE_HOST' (ssh target: $ssh_target)" >&2
        exit 1
    fi

    # Build remote subagent command (pass through all flags except --host/--dir)
    local remote_cmd="subagent"
    case "$BACKEND" in
        codex)  remote_cmd+=" --codex" ;;
        claude) remote_cmd+=" --claude" ;;
    esac
    case "$MODE" in
        blocking) remote_cmd+=" --blocking" ;;
        persona) remote_cmd+=" --persona" ;;
    esac
    [[ "$AGENT" != "main" ]] && remote_cmd+=" --agent '$AGENT'"
    [[ -n "$SESSION_ID" ]] && remote_cmd+=" --session '$SESSION_ID'"
    if [[ -n "$PROMPT" ]]; then
        local escaped_prompt="${PROMPT//\'/\'\\\'\'}"
        remote_cmd+=" '$escaped_prompt'"
    fi

    # Prepend cd if --dir specified
    if [[ -n "$REMOTE_DIR" ]]; then
        remote_cmd="cd '$REMOTE_DIR' && $remote_cmd"
    fi

    case "$MODE" in
        persona)
            # Interactive: exec ssh -t for TUI passthrough
            exec ssh -t "$ssh_target" "$remote_cmd"
            ;;
        blocking)
            # Blocking: stream output through
            ssh "$ssh_target" "$remote_cmd"
            ;;
        async)
            # Async: capture output, prefix with host info
            local output
            output=$(ssh "$ssh_target" "$remote_cmd" 2>&1)
            echo "Host: $REMOTE_HOST ($ssh_target)"
            echo "$output"
            ;;
    esac
}

# --- Dispatch ---
if [[ -n "$REMOTE_HOST" ]]; then
    run_remote
else
    case "$MODE" in
        async)    run_async    ;;
        blocking) run_blocking ;;
        persona)  run_persona  ;;
    esac
fi
