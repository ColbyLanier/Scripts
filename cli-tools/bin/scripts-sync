#!/usr/bin/env bash
# scripts-sync - Bi-directional git sync between Mac and WSL for ~/Scripts
# TAGS: sync, git
# AUDIENCE: human, agent
#
# Usage:
#   scripts-sync                      # Same as 'push'
#   scripts-sync push                 # Commit+push local, pull on remote
#   scripts-sync pull                 # Commit+push on remote, pull locally
#   scripts-sync status               # Show git status on both machines
#   scripts-sync phone <src>:<dest>   # Push files to phone via scp
#   scripts-sync phone <folder>/      # Push folder to phone ~/macros/
#
# Options:
#   --path <subfolder>    Only sync files in this subfolder
#   --message <msg>       Custom commit message
#   --dry-run             Show what would happen without doing it
#   --no-pull             Just commit+push locally, skip pull on remote
#   -h, --help            Show help

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

# Config
SCRIPTS_DIR="$HOME/Scripts"
MAC_IP="100.95.109.23"
WSL_IP="100.66.10.74"
SSH_OPTS="-o ConnectTimeout=5 -o BatchMode=yes"

# State
MODE="push"
SYNC_PATH=""
COMMIT_MSG=""
DRY_RUN=false
NO_PULL=false
PHONE_ARGS=()

# ============ Helpers ============

is_mac() {
    [[ "$(uname)" == "Darwin" ]]
}

get_hostname_short() {
    if is_mac; then
        echo "mac"
    else
        echo "wsl"
    fi
}

remote_alias() {
    if is_mac; then
        echo "wsl"
    else
        echo "mac"
    fi
}

log_info() {
    echo -e "${BLUE}->${NC} $*"
}

log_ok() {
    echo -e "  ${GREEN}OK${NC} $*"
}

log_warn() {
    echo -e "  ${YELLOW}!!${NC} $*"
}

log_err() {
    echo -e "  ${RED}ERR${NC} $*"
}

log_dry() {
    echo -e "  ${YELLOW}[dry-run]${NC} $*"
}

show_help() {
    cat << 'EOF'
scripts-sync - Bi-directional git sync between Mac and WSL for ~/Scripts

Usage:
    scripts-sync [push]                Commit+push locally, pull on remote
    scripts-sync pull                  Commit+push on remote, pull locally
    scripts-sync status                Git status on both Mac and WSL
    scripts-sync phone <src>:<dest>    Push file to phone via scp
    scripts-sync phone <folder>/       Push folder to phone ~/macros/

Options:
    --path <subfolder>    Only stage files under this path (e.g. --path mobile)
    --message <msg>       Custom commit message (default: auto-generated)
    --dry-run             Preview what would be committed/pushed
    --no-pull             Only commit+push locally; don't pull on remote
    -h, --help            Show this help

Examples:
    scripts-sync                              # Push all changes, pull on remote
    scripts-sync push --path mobile           # Only sync mobile/ subfolder
    scripts-sync pull --message "fix typo"    # Pull remote changes with custom msg
    scripts-sync status                       # Compare both machines
    scripts-sync push --dry-run               # Preview without doing anything
    scripts-sync phone mobile/termux-bashrc-template:~/.bashrc
    scripts-sync phone mobile/macros/         # Push folder to ~/macros/ on phone

Auto-commit message format:
    sync(<path>): <N> files changed from <hostname>

Notes:
    - Mac uses 'ssh wsl' to reach WSL
    - WSL uses 'ssh mac' to reach Mac
    - If pull fails due to merge conflict, you'll be prompted to resolve manually
    - Phone mode uses scp (no git involved)
EOF
}

# ============ Git Operations ============

# Count changes in a git repo (local or remote via ssh)
# Args: [ssh_target] (empty for local)
# Returns: prints number of changed files
count_changes() {
    local ssh_target="${1:-}"
    local path_arg=""
    [[ -n "$SYNC_PATH" ]] && path_arg="-- $SYNC_PATH"

    if [[ -z "$ssh_target" ]]; then
        git -C "$SCRIPTS_DIR" status --porcelain $path_arg 2>/dev/null | wc -l | tr -d ' '
    else
        ssh $SSH_OPTS "$ssh_target" \
            "cd ~/Scripts && git status --porcelain $path_arg 2>/dev/null | wc -l | tr -d ' '" 2>/dev/null || echo "0"
    fi
}

# Get a short summary of changes for commit message
# Args: [ssh_target]
summarize_changes() {
    local ssh_target="${1:-}"
    local path_arg=""
    [[ -n "$SYNC_PATH" ]] && path_arg="-- $SYNC_PATH"

    local status_output
    if [[ -z "$ssh_target" ]]; then
        status_output=$(git -C "$SCRIPTS_DIR" status --porcelain $path_arg 2>/dev/null)
    else
        status_output=$(ssh $SSH_OPTS "$ssh_target" \
            "cd ~/Scripts && git status --porcelain $path_arg" 2>/dev/null || echo "")
    fi

    if [[ -z "$status_output" ]]; then
        echo "no changes"
        return
    fi

    local added modified deleted
    added=$(echo "$status_output" | grep -c '^\?' || true)
    modified=$(echo "$status_output" | grep -c '^ \?M' || true)
    deleted=$(echo "$status_output" | grep -c '^ \?D' || true)
    local total
    total=$(echo "$status_output" | wc -l | tr -d ' ')

    local parts=()
    [[ "$added" -gt 0 ]] && parts+=("${added} added")
    [[ "$modified" -gt 0 ]] && parts+=("${modified} modified")
    [[ "$deleted" -gt 0 ]] && parts+=("${deleted} deleted")

    if [[ ${#parts[@]} -eq 0 ]]; then
        echo "${total} files changed"
    else
        local IFS=', '
        echo "${parts[*]}"
    fi
}

# Build the auto commit message
build_commit_msg() {
    local ssh_target="${1:-}"
    local hostname
    hostname=$(get_hostname_short)

    if [[ -n "$COMMIT_MSG" ]]; then
        echo "$COMMIT_MSG"
        return
    fi

    local path_label="${SYNC_PATH:-all}"
    local summary
    summary=$(summarize_changes "$ssh_target")

    echo "sync(${path_label}): ${summary} from ${hostname}"
}

# Stage, commit, push on a machine
# Args: ssh_target (empty string = local)
git_commit_push() {
    local ssh_target="${1:-}"
    local location
    if [[ -z "$ssh_target" ]]; then
        location="local"
    else
        location="$ssh_target"
    fi

    log_info "Checking for changes on ${location}..."

    local change_count
    change_count=$(count_changes "$ssh_target")

    if [[ "$change_count" -eq 0 ]]; then
        log_ok "No uncommitted changes on ${location}"
    else
        local msg
        msg=$(build_commit_msg "$ssh_target")

        local add_arg
        if [[ -n "$SYNC_PATH" ]]; then
            add_arg="$SYNC_PATH"
        else
            add_arg="-A"
        fi

        if [[ "$DRY_RUN" == true ]]; then
            log_dry "Would stage ${change_count} file(s) on ${location}"
            log_dry "Would commit: ${msg}"
            log_dry "Would push to origin"

            # Show what files would be staged
            if [[ -z "$ssh_target" ]]; then
                local path_arg=""
                [[ -n "$SYNC_PATH" ]] && path_arg="-- $SYNC_PATH"
                echo ""
                echo -e "  ${BOLD}Files:${NC}"
                git -C "$SCRIPTS_DIR" status --porcelain $path_arg 2>/dev/null | while read -r line; do
                    echo "    $line"
                done
            else
                echo ""
                echo -e "  ${BOLD}Files:${NC}"
                local path_arg=""
                [[ -n "$SYNC_PATH" ]] && path_arg="-- $SYNC_PATH"
                ssh $SSH_OPTS "$ssh_target" \
                    "cd ~/Scripts && git status --porcelain $path_arg" 2>/dev/null | while read -r line; do
                    echo "    $line"
                done
            fi
            return 0
        fi

        log_info "Staging ${change_count} file(s) on ${location}..."

        if [[ -z "$ssh_target" ]]; then
            git -C "$SCRIPTS_DIR" add $add_arg
            git -C "$SCRIPTS_DIR" commit -m "$msg" --quiet
        else
            ssh $SSH_OPTS "$ssh_target" \
                "cd ~/Scripts && git add $add_arg && git commit -m $(printf '%q' "$msg") --quiet" 2>/dev/null
        fi

        log_ok "Committed: ${msg}"
    fi

    # Push
    if [[ "$DRY_RUN" == true ]]; then
        return 0
    fi

    log_info "Pushing to origin from ${location}..."

    if [[ -z "$ssh_target" ]]; then
        if git -C "$SCRIPTS_DIR" push --quiet 2>/dev/null; then
            log_ok "Push succeeded"
        else
            log_err "Push failed"
            return 1
        fi
    else
        if ssh $SSH_OPTS "$ssh_target" \
            "cd ~/Scripts && git push --quiet" 2>/dev/null; then
            log_ok "Push succeeded"
        else
            log_err "Push failed on ${ssh_target}"
            return 1
        fi
    fi
}

# Pull on a machine
# Args: ssh_target (empty string = local)
git_pull() {
    local ssh_target="${1:-}"
    local location
    if [[ -z "$ssh_target" ]]; then
        location="local"
    else
        location="$ssh_target"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        log_dry "Would pull on ${location}"
        return 0
    fi

    log_info "Pulling on ${location}..."

    local pull_output
    if [[ -z "$ssh_target" ]]; then
        pull_output=$(git -C "$SCRIPTS_DIR" pull --ff-only 2>&1) || {
            log_err "Pull failed on ${location}"
            echo ""
            echo -e "  ${RED}Output:${NC}"
            echo "$pull_output" | while read -r line; do
                echo "    $line"
            done
            echo ""
            echo -e "  ${YELLOW}Possible merge conflict. Resolve manually:${NC}"
            echo "    cd ~/Scripts && git status"
            echo "    git merge --abort   # to undo"
            echo "    git mergetool       # to resolve"
            return 1
        }
    else
        pull_output=$(ssh $SSH_OPTS "$ssh_target" \
            "cd ~/Scripts && git pull --ff-only" 2>&1) || {
            log_err "Pull failed on ${location}"
            echo ""
            echo -e "  ${RED}Output:${NC}"
            echo "$pull_output" | while read -r line; do
                echo "    $line"
            done
            echo ""
            echo -e "  ${YELLOW}Possible merge conflict on ${ssh_target}. Resolve manually:${NC}"
            echo "    ssh ${ssh_target} 'cd ~/Scripts && git status'"
            echo "    ssh ${ssh_target} 'cd ~/Scripts && git merge --abort'"
            return 1
        }
    fi

    if echo "$pull_output" | grep -q "Already up to date"; then
        log_ok "Already up to date on ${location}"
    else
        log_ok "Pulled on ${location}"
        # Show what changed
        echo "$pull_output" | grep -E '^\s*([\w/]+)\s*\|' | while read -r line; do
            echo "    $line"
        done
    fi
}

# ============ Modes ============

do_push() {
    local remote
    remote=$(remote_alias)

    echo -e "${BOLD}=== scripts-sync push ===${NC}"
    echo ""

    # Step 1: commit+push locally
    git_commit_push "" || return 1

    # Step 2: pull on remote
    if [[ "$NO_PULL" == true ]]; then
        echo ""
        log_info "Skipping pull on ${remote} (--no-pull)"
    else
        echo ""
        git_pull "$remote" || return 1
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Sync complete.${NC}"
}

do_pull() {
    local remote
    remote=$(remote_alias)

    echo -e "${BOLD}=== scripts-sync pull ===${NC}"
    echo ""

    # Step 1: commit+push on remote
    git_commit_push "$remote" || return 1

    # Step 2: pull locally
    if [[ "$NO_PULL" == true ]]; then
        echo ""
        log_info "Skipping local pull (--no-pull)"
    else
        echo ""
        git_pull "" || return 1
    fi

    echo ""
    echo -e "${GREEN}${BOLD}Sync complete.${NC}"
}

do_status() {
    local remote
    remote=$(remote_alias)

    echo -e "${BOLD}=== scripts-sync status ===${NC}"
    echo ""

    # Local status
    local local_name
    local_name=$(get_hostname_short)

    echo -e "${BOLD}${local_name} (local):${NC}"
    local local_status
    local_status=$(git -C "$SCRIPTS_DIR" status --short 2>/dev/null)
    local local_branch
    local_branch=$(git -C "$SCRIPTS_DIR" branch --show-current 2>/dev/null)
    local local_log
    local_log=$(git -C "$SCRIPTS_DIR" log --oneline -3 2>/dev/null)

    echo -e "  Branch: ${GREEN}${local_branch}${NC}"
    if [[ -z "$local_status" ]]; then
        echo -e "  Status: ${GREEN}clean${NC}"
    else
        echo -e "  Status: ${YELLOW}$(echo "$local_status" | wc -l | tr -d ' ') uncommitted file(s)${NC}"
        echo "$local_status" | while read -r line; do
            echo "    $line"
        done
    fi
    echo "  Recent commits:"
    echo "$local_log" | while read -r line; do
        echo "    $line"
    done

    echo ""

    # Remote status
    echo -e "${BOLD}${remote} (remote):${NC}"
    if ! ssh $SSH_OPTS "$remote" "true" 2>/dev/null; then
        echo -e "  ${RED}Unreachable via SSH${NC}"
        return 0
    fi

    local remote_status
    remote_status=$(ssh $SSH_OPTS "$remote" "cd ~/Scripts && git status --short" 2>/dev/null)
    local remote_branch
    remote_branch=$(ssh $SSH_OPTS "$remote" "cd ~/Scripts && git branch --show-current" 2>/dev/null)
    local remote_log
    remote_log=$(ssh $SSH_OPTS "$remote" "cd ~/Scripts && git log --oneline -3" 2>/dev/null)

    echo -e "  Branch: ${GREEN}${remote_branch}${NC}"
    if [[ -z "$remote_status" ]]; then
        echo -e "  Status: ${GREEN}clean${NC}"
    else
        echo -e "  Status: ${YELLOW}$(echo "$remote_status" | wc -l | tr -d ' ') uncommitted file(s)${NC}"
        echo "$remote_status" | while read -r line; do
            echo "    $line"
        done
    fi
    echo "  Recent commits:"
    echo "$remote_log" | while read -r line; do
        echo "    $line"
    done

    # Compare HEADs
    echo ""
    local local_head remote_head
    local_head=$(git -C "$SCRIPTS_DIR" rev-parse HEAD 2>/dev/null)
    remote_head=$(ssh $SSH_OPTS "$remote" "cd ~/Scripts && git rev-parse HEAD" 2>/dev/null)

    if [[ "$local_head" == "$remote_head" ]]; then
        echo -e "${GREEN}Both machines are on the same commit: ${local_head:0:7}${NC}"
    else
        echo -e "${YELLOW}Machines are on different commits:${NC}"
        echo -e "  Local:  ${local_head:0:7}"
        echo -e "  Remote: ${remote_head:0:7}"
    fi
}

do_phone() {
    echo -e "${BOLD}=== scripts-sync phone ===${NC}"
    echo ""

    if [[ ${#PHONE_ARGS[@]} -eq 0 ]]; then
        log_err "No files specified."
        echo ""
        echo "Usage:"
        echo "  scripts-sync phone <src>:<dest>          # Push file to phone"
        echo "  scripts-sync phone <folder>/             # Push folder to ~/macros/"
        echo ""
        echo "Examples:"
        echo "  scripts-sync phone mobile/termux-bashrc-template:~/.bashrc"
        echo "  scripts-sync phone mobile/macros/"
        return 1
    fi

    # Check phone is reachable
    if ! ssh $SSH_OPTS phone "true" 2>/dev/null; then
        log_err "Phone unreachable via SSH"
        return 1
    fi

    for arg in "${PHONE_ARGS[@]}"; do
        if [[ "$arg" == *:* ]]; then
            # Explicit src:dest mapping
            local src="${arg%%:*}"
            local dest="${arg#*:}"

            # Resolve src relative to Scripts dir if not absolute
            if [[ "$src" != /* ]]; then
                src="${SCRIPTS_DIR}/${src}"
            fi

            if [[ ! -e "$src" ]]; then
                log_err "Source not found: ${src}"
                continue
            fi

            if [[ "$DRY_RUN" == true ]]; then
                log_dry "Would copy ${src} -> phone:${dest}"
                continue
            fi

            log_info "Copying ${src} -> phone:${dest}"
            if scp -q "$src" "phone:${dest}" 2>/dev/null; then
                log_ok "Pushed $(basename "$src")"
            else
                log_err "Failed to push $(basename "$src")"
            fi

        elif [[ "$arg" == */ ]]; then
            # Folder mode: push to ~/macros/ on phone
            local src="${arg%/}"
            if [[ "$src" != /* ]]; then
                src="${SCRIPTS_DIR}/${src}"
            fi

            if [[ ! -d "$src" ]]; then
                log_err "Directory not found: ${src}"
                continue
            fi

            local dest_dir="~/macros/"

            if [[ "$DRY_RUN" == true ]]; then
                log_dry "Would copy ${src}/ -> phone:${dest_dir}"
                local file_count
                file_count=$(find "$src" -type f | wc -l | tr -d ' ')
                log_dry "${file_count} file(s) in directory"
                continue
            fi

            # Ensure target dir exists
            ssh $SSH_OPTS phone "mkdir -p macros" 2>/dev/null

            log_info "Copying ${src}/ -> phone:${dest_dir}"
            if scp -q -r "$src"/* "phone:macros/" 2>/dev/null; then
                log_ok "Pushed directory contents"
            else
                log_err "Failed to push directory"
            fi
        else
            # Single file without dest - push to ~/macros/
            local src="$arg"
            if [[ "$src" != /* ]]; then
                src="${SCRIPTS_DIR}/${src}"
            fi

            if [[ ! -e "$src" ]]; then
                log_err "Source not found: ${src}"
                continue
            fi

            local dest="macros/$(basename "$src")"

            if [[ "$DRY_RUN" == true ]]; then
                log_dry "Would copy ${src} -> phone:~/${dest}"
                continue
            fi

            ssh $SSH_OPTS phone "mkdir -p macros" 2>/dev/null
            log_info "Copying ${src} -> phone:~/${dest}"
            if scp -q "$src" "phone:${dest}" 2>/dev/null; then
                log_ok "Pushed $(basename "$src")"
            else
                log_err "Failed to push $(basename "$src")"
            fi
        fi
    done

    echo ""
    echo -e "${GREEN}${BOLD}Phone sync complete.${NC}"
}

# ============ Parse Arguments ============

# First pass: extract mode (first non-flag argument)
ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        --path)
            SYNC_PATH="${2:?--path requires a value}"
            shift 2
            ;;
        --message)
            COMMIT_MSG="${2:?--message requires a value}"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --no-pull)
            NO_PULL=true
            shift
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            echo "Use --help for usage" >&2
            exit 1
            ;;
        *)
            ARGS+=("$1")
            shift
            ;;
    esac
done

# Parse positional args
if [[ ${#ARGS[@]} -gt 0 ]]; then
    MODE="${ARGS[0]}"
    # Remaining args are for phone mode
    if [[ ${#ARGS[@]} -gt 1 ]]; then
        PHONE_ARGS=("${ARGS[@]:1}")
    fi
fi

# ============ Execute ============

case "$MODE" in
    push)
        do_push
        ;;
    pull)
        do_pull
        ;;
    status)
        do_status
        ;;
    phone)
        do_phone
        ;;
    *)
        echo -e "${RED}Unknown mode: ${MODE}${NC}" >&2
        echo "Use --help for usage" >&2
        exit 1
        ;;
esac
